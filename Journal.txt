Chapter 1: Building Our First Resource (1)
    Ash is a set of tools you can use to describe and build the Domain Model. For this we will set up the Tunez Application, install Ash, and build our first reasource.

    Getting the Ball Rolling
        This will be a lightweight spotify app (without the music). 

        Setting Up Your Development Environement
            They created a starter github for this project so run
                git clone https://github.com/sevenseacat/tunez
                cd tunez
                mix setup
                mix phx.server

            IF all that works you have everthing you need. if not make sure you have asdf and insall the files in the .tool-versions

        Welcome to ASH!!
            Now that we know its all working we can now be sure to insall an other depedency which is ingiter, this is already ready to go from the Tunez project. This will set some new deps and formatter lines as well as fixing the config to be sure to have all the right depedency.
                mix igniter.insall ash

            Next we need to set up the post_gres for ash as well. This will do the following add and fetch ash_postgres Hex package, add more autoformatting to config and formatter, update the database to use ASH, update some alias to use ASH instead of Ecto, Generate our first migration, generate the extensions for the config. 
                mix igniter.install ash_postgres

        Reasources and Domains
            One of the most important concept is resource in ASH. They are domain model objects (nouns our app revolves around). 

            Related resources are grouped together into Domains. What this means for our app is that we will define several domainds for distinct ideas within the app, Music, Album, Artist, Track User, Notifications

            We will set attributes for each. which is data that maps to keys of the resource's struct. 

        Generating the Artist Resource
            First we can create the Artist resource. It will hold the artists name and biography. For this we will use a generator with this command. It will do the following: create a new module Tunez.Music.Artist, a new domain module named Tunez.Music (check out lib/tunez/music/artist.ex) 
                mix ash.gen.resource Tunez.Music.Artist -- extend postgres

            Now that we have the general domain we can now populate it with a table and some attributes
                defmodule Tunez.Music.Artist do
                    use Ash.Resource, otp_app: :tunez, domain: Tunez.Music, data_layer: AshPostgres.DataLayer

                    postgres do
                        table("artists")
                        repo(Tunez.Repo)
                    end
                end

            Then we can set some attributes: first we want a primary key UUID key, time stamp fields (create_timestamp, update_timestamp, name, biography) as you can see below a lot of this can be done with just simple keywords.
                attributes do
                    uuid_primary_key(:id)

                    attribute :name, :string do
                    allow_nil?(false)
                    end

                    attribute(:biography, :string)
                    create_timestamp(:inserted_at)
                    update_timestamp(:updated_at)
                end

            We still need to create the database and there is a command for that (ash.codegen) let's start to look into that now.

        Auto-generating Database Migrations
            If you have run with ecto before you will know that everyting needs to stay up to date and if you update a schema or datebases independently you will not have an up to date DB. Ash will sidestep this and make sure that everything is done together. `mix ash.codegen' will do the following:
                create shapshots of your current Reasources
                compare them to the older snapshot (if extisting)
                generate deltas for the changes.

            Let's run that command to create the artists. This created a few files for us, so that we can keep everything up to date: a snapshot priv/resource_snapshots/repo/artists/[*].json, and the migration for the artist resource priv/repo/migrations/[*]_create_artists.ex
                mix ash.codegen create_artists

            Let's check out the migration that was just created.
                def up do
                    create table(:artists, primary_key: false) do
                    add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
                    add :name, :text, null: false
                    add :biography, :text

                    add :inserted_at, :utc_datetime_usec,
                        null: false,
                        default: fragment("(now() AT TIME ZONE 'utc')")

                    add :updated_at, :utc_datetime_usec,
                        null: false,
                        default: fragment("(now() AT TIME ZONE 'utc')")
                    end
                end

                def down do
                    drop table(:artists)
                end
            
            Looks just like something that you would create doing it all yourself. This all came from the schema we created and then the Ash generator. We can now migrate with the mix ash command.
                mix ash.migrate

    Oh, CRUD! - Defining Basic Actions
        Remember that CRUSD is:
            Create
            Read
            Update
            Delete

        We will need to define those actions within our database. Remembering that everything that we want to do can be done within the artists.ex file simply add in an action block and go.

        Defining a Create Action
            All actions require a type (create, read, update, destroy) I will put all the changes to the module below but there will be a few thing to look for. As of right now we just the action and an atom to call it with, and then what it will accept

              actions do
                create :create do
                accept([:name, :biography])
            end
        
        Creating Records via a Changeset
            Create a changeset and then pass it to a process to add it.
                iex -S mix
                Tunez.Music.Artist
                |> Ash.Changeset.for_create(:create, %{
                name: "Valkyrie's Fury",
                biography: "A power metal band hailing from Tallinn, Estonia"
                })
                |> Ash.create()

            Now we can see if it did infact work with a psql command
                psql tunez_dev
                tunez_dev=# select * from artists;
                    -[ RECORD 1 ]----------------------------------------------
                    id | [uuid]
                    name | Valkyrie's Fury
                    biography | A power metal band hailing from Tallinn, Estonia
                    inserted_at | [now]
                    updated_at | [now]
            
            We can now check to see if you can do some other creates with or without name etc.

        Creating Records via a Code Interface
            So we want to now use a Domain to interact with a database so that we can have lower level (reasources) work done through a domain. Let's head to the file /lib/tunez/music.ex. This is a domain.
                resources do
                    resource Tunez.Music.Artist do
                        define :create_artist, action: :create
                    end
                end

            With this in place we can no interact with the create_artist function.
                iex(5)> h Tunez.Music.create_artist

                 def create_artist(params \\ nil, opts \\ nil)                  

                Calls the create action on Tunez.Music.Artist.

                # Inputs

                • name
                • biography

            Okay so now we can use this syntax to create an artist from the music module.
                iex > Tunez.Music.create_artist(%{
                name: "Valkyrie's Fury",
                biography: "A power metal band hailing from Tallinn, Estonia"
                })    

            Let's quickly look at the seed logic in the mix.exs so that we can see what kind of work is done with the `mix seed` command.
                  defp aliases do
                    [
                    setup: ["deps.get", "ash.setup", "assets.setup", "assets.build", "run priv/repo/seeds.exs"],
                    "ecto.setup": ["ecto.create", "ecto.migrate"],
                    seed: [
                        "run priv/repo/seeds/01-artists.exs",

            With this line uncommented we can run the mix seed to create some artists.
                mix seed

        Defining a Read Action
            now we can add in the read action to the resource Artist
                read :read do
                    primary?(true)
                end

            Then add it to the music Domain
                define :read_artist, action: :read

                iex> Tunez.Music.read_artists()

            ``Manually Reading Records Via a Query``
                This will now work for us. Right now as we didn't set some params for the read we will just pull everything the other way is to create a temp artist struct and then pass some queries to it. The basic idea is: create basic query > pipe through functions to add params > Pass to Ash for processing, see below.
                    iex(2)> Tunez.Music.Artist
                    Tunez.Music.Artist
                    iex(3)> |> Ash.Query.for_read(:read)
                    #Ash.Query<resource: Tunez.Music.Artist, action: :read>
                    Then you can pipe that query into Ash’s query functions like sort and limit. The
                    query keeps getting the extra conditions added to it, but it isn’t yet being run
                    in the database.
                    iex(4)> |> Ash.Query.sort(name: :asc)
                    #Ash.Query<resource: Tunez.Music.Artist, action: :read, sort: [name: :asc]>
                    iex(5)> |> Ash.Query.limit(1)
                    #Ash.Query<resource: Tunez.Music.Artist, action: :read, sort: [name: :asc],
                    limit: 1>
                    Then, when it’s time to go, Ash can call it and return the data you requested,
                    with all conditions applied:
                    iex(6)> |> Ash.read()
                    SELECT a0."id", a0."name", a0."biography", a0."inserted_at", a0."updated_at"
                    FROM "artists" AS a0 ORDER BY a0."name" LIMIT $1 [1]
                    {:ok, [#Tunez.Music.Artist<...>]}

            `Reading a Single Record by Primary Key` 
                Right now again if we were to try a read it will retieve everything but there is a simple way to use a resource and be able to pass a param and get a record by that param. Head back to the music domain and then add this.
                    define :get_artist_by_id, action: :read, get_by: :id

        Defining an Update Action
            Now we can add in an update. Remember that we now just need to add in the action and then add it to a module.
                update :update do
                    accept [:name, :biography]
                end

                define :update_artist, action: :update

            How do we use this? Well we need an artist and then we need to send it the information that will be updated.
                iex(3)> artist = Tunez.Music.get_artist_by_id!("an-artist-id")
                #Tunez.Music.Artist<id: "an-artist-id", ...>
                Now we can either use the code interface we added or create a changeset and
                apply it, as we did for create.
                iex(4)> # Via the code interface
                iex(5)> Tunez.Music.update_artist(artist, %{name: "Hello"})
                UPDATE "artists" AS a0 SET "updated_at" = (CASE WHEN $1::text !=
                a0."name"::text THEN $2::timestamp ELSE a0."updated_at"::timestamp END)
                ::timestamp, "name" = $3::text WHERE (a0."id"::uuid = $4::uuid) RETURNING
                a0."id", a0."name", a0."biography", a0."inserted_at", a0."updated_at"
                ["Hello", [now], "Hello", "an-artist-id"]
                {:ok, #Tunez.Music.Artist<id: "an-artist-id", name: "Hello", ...>}
                iex(6)> # Or via a changeset
                iex(7)> artist
                |> Ash.Changeset.for_update(:update, %{name: "World"})
                |> Ash.update()
                «an almost-identical SQL statement»
                {:ok, #Tunez.Music.Artist<id: "an-artist-id", name: "World", ...>}

        Defining a Destroy Action
            Now we simply need to add in a delete (destroy) and we have at least the start of CRUD
                destroy :destroy do
                end

                define :destroy_artist, action: :destroy

            How we will use it is slightly different as we would like to use a changeset
                ex(3)> artist = Tunez.Music.get_artist_by_id!("the-artist-id")
                #Tunez.Music.Artist<id: "an-artist-id", ...>
                iex(4)> # Via the code interface
                iex(5)> Tunez.Music.destroy_artist(artist)
                DELETE FROM "artists" AS a0 WHERE (a0."id" = $1) ["the-artist-id"]
                :ok
                iex(6)> # Or via a changeset
                iex(7)> artist
                |> Ash.Changeset.for_destroy(:destroy)
                |> Ash.destroy()
                DELETE FROM "artists" AS a0 WHERE (a0."id" = $1) ["the-artist-id"]
                :ok

        Default Actions
            Now that we know how to setup some of the actions we can just use a module and set some default actions as ASH is set to just use CRUD off the bat. Let's go to the artist.ex resource and replace everything with this.
                defaults [:create, :read, :update, :destroy]
                default_accept [:name, :biography]

            What is great about this is that the normal default here add in a lot of functionality that you would want (or and not use) like pagination etc.

    Integrating Actions into LiveViews
        Now that we have the database and some dummy entries we can try to actually look at the database and teh Phoenix integration.
            mix phx.server
            # Then head to localhost:4000 and check it out.
        
        What you are seeing on the main page is the module in lib/tunez_web/live/artist/index_live.ex. They set us up with some dummy artist but we can replace the artists with a call to the database.
            artists = Tunez.Music.read_artists!() # Notice the ! this will jsut return the artists not a condition as well

        Viewing an Artist Profile
            Clicking on an image will take you to the profile page using TunezWeb.Artists.ShowLive, again we see that there is some default data here and we can now change the default with get_artist_by_id! (again the !)
                def handle_params(%{"id" => artist_id} =  params, _url, socket) do
                    artist = Tunez.Music.get_artist_by_id!(artist_id)
                    ...
                end
        
        Creating Artists with AshPhoenix.Form
            In a normal way we would define a changeset and then cast that changeset with the Repo.insert{} like below with ash there is an other way.
            In code, the changeset function might look something like this:
                defmodule Tunez.Music.Artist do
                    def changeset(artist, attrs) do
                        artist
                        |> cast(attrs, [:name, :biography])
                        |> validate_required([:name])
                    end
            And the context module that uses it might look like this:
                defmodule Tunez.Music do
                    def create_artist(attrs \\ %{}) do
                        %Artist{}
                        |> Artist.changeset(attrs)
                        |> Repo.insert()
                    end

            "Hello, AshPhoenix"
                AshPhoenix is a core library that can do a few things but the main purpose is forms.
                    mix igniter.install ash_phoenix

            "A Form for an Action"
                This created a form for us that we can use right away. Lets try it out. 
                    iex -S mix
                    iex(1)> form = AshPhoenix.Form.for_create(Tunez.Music.Artist, :create)
                    #AshPhoenix.Form<
                    resource: Tunez.Music.Artist,
                    action: :create,
                    type: :create,
                    params: %{},
                    source: #Ash.Changeset<
                    domain: Tunez.Music,
                    action_type: :create,
                    action: :create,
                    attributes: %{},
                    ...

                    iex(2)> AshPhoenix.Form.validate(form, %{name: "Best Band Ever"})
                    #AshPhoenix.Form<
                    resource: Tunez.Music.Artist,
                    action: :create,
                    type: :create,
                    params: %{name: "Best Band Ever"},
                    source: #Ash.Changeset<
                    domain: Tunez.Music,
                    action_type: :create,
                    action: :create,
                    attributes: %{name: "Best Band Ever"},
                    relationships: %{},
                    errors: [],
                    data: %Tunez.Music.Artist{...},
                    valid?: true➤
                    >,
                    ...

                    iex(5)> AshPhoenix.Form.submit(form, params: %{name: "Best Band Ever"})
                    INSERT INTO "artists" ("id","name","inserted_at","updated_at") VALUES
                    ($1,$2,$3,$4) RETURNING "updated_at","inserted_at","biography","name","id"
                    [[uuid], "Best Band Ever", [timestamp], [timestamp]]
                    {:ok,
                    %Tunez.Music.Artist{
                    id: [uuid],
                    name: "Best Band Ever",
                    ...

                As you can see we have some built in functions that will create and then validate as well as insert the new band into the database. With this taken care of we can now try to add the domain to the Domain so that we can now use the form to do all the above

            "Using the AshPhoenix Domain Extension"
                The functionality that we are using atm is to call the :create atom and that feels a bit problematic for what we have already done. With that being said we can now add the AshPhoenix extension to the Music Domain to leverage the new form.
                    defmodule Tunez.Music do
                        use Ash.Domain, otp_app: :tunez, extensions: [AshPhoenix]➤
                        # ...    
                
                Lets try out the new way of doing things. Now we can simply append the form_to to any function and it will create a form to do that thing. Keep in mind that you will need to have the extension within the module.
                    iex(5)> AshPhoenix.Form.for_create(Tunez.Music.Artist, :create)
                    #AshPhoenix.Form<resource: Tunez.Music.Artist, action: :create, ...>
                    iex(6)> Tunez.Music.form_to_create_artist()
                    #AshPhoenix.Form<resource: Tunez.Music.Artist, action: :create, ...>

            "Integrating a Form into a LiveView"
                We can now go to lib/tunez/live/artists/form_live.ex this is where you would go to create a new artist form.
                    form = Tunez.Music.form_to_create_artist()

                Its really that simple. So long as you have some form of the html for the render you will not have access to the form for anything that has the extension installed. There is a built in validate event that is currently not doing anything so we should now define it.
                    def handle_event("validate", %{"form" => form_data}, socket) do
                        socket =
                        update(socket, :form, fn form ->
                            AshPhoenix.Form.validate(form, form_data)
                        end)
                        {:noreply, socket}
                    end

                We now need to take care of the submit there is also a way to do that as well. Keep in mind that you are calling the "save" event when you save the form. It is already defined below the render so lets flesh it out. You will need to take care of 2 events a valid submit and an issue both of those should have some sort of flash message as well as put you back into a page.
                    def handle_event("save", %{"form" => form_data}, socket) do
                        case AshPhoenix.Form.submit(socket.assigns.form, params: form_data) do
                        {:ok, artist} ->
                            socket =
                            socket
                            |> put_flash(:info, "Artist saved successfully")
                            |> push_navigate(to: ~p"/artists/#{artist}")

                            {:noreply, socket}

                        {:error, form} ->
                            socket =
                            socket
                            |> put_flash(:error, "Could not save artist data")
                            |> assign(:form, form)

                            {:noreply, socket}
                        end
                    end

                Great now we can add an artist but we don't have a way to edit and then delete.

        Updating Artists with the same Code
            Remember that the update and create were very similar function calls where one just needs an artist id to be called as well. Also keep in mind that once you are looking at an artist you will have the artist within the params of the page. So so long as you have those values and functions you can create or edit an artist. What is great is that we can pattern match to an existing artist in the mount so that we can pull the data for the artist and then do an update.
                def mount(%{"id" => artist_id}, _session, socket) do
                    artist = Tunez.Music.get_artist_by_id!(artist_id)
                    form = Tunez.Music.form_to_update_artist(artist)

                    socket =
                    socket
                    |> assign(:form, to_form(form))
                    |> assign(:page_title, "Update Artist")

                    {:ok, socket}
                end

            Simple but keep in mind that you are setting the form to have the existing data for the artist then you can edit with an update.
                

        Deleting Artists Data
            This is the destroy action that we created earlier. We now need to head to the show_live.ex in order to create this event. Looking at the show_live.ex we see that the delete artist button will call the delete event. So in order to do this we need to pass the artists id and then run the destroy function to do so.
                def handle_event("destroy-artist", _params, socket) do
                    case Tunez.Music.destroy_artist(socket.assigns.artist) do
                    :ok ->
                        socket =
                        socket
                        |> put_flash(:info, "Artist deleted successfully")
                        |> push_navigate(to: ~p"/")

                        {:noreply, socket}

                    {:error, error} ->
                        Logger.info("Could not delete artist '#{socket.assigns.artist.id}':#{inspect(error)}")

                        socket =
                        socket
                        |> put_flash(:error, "Could not delete artist")

                        {:noreply, socket}
                    end
                end

    That is it we now have forms for creating an artist editing an artists and even the funcionality for deleting an artist. There is so much that you can do here to make this easier but we will more on to more functionality.
 
Chapter 2: Extending Reasources with Business Logic (33)
    Reasources and Relationships
        We have created a single reasource now lets create an album reasource. 
            mix ash.gen.resource Tunez.Music.Album --extend postgres

        We now have some new files, we want to add these things to the DB:
            Artist, Album name, Year released, Image

        Let's head over to lib/tunez/music/album.ex
            attributes do
                uuid_primary_key :id
                attribute :name, :string do
                    allow_nil? false
                end
                attribute :year_released, :integer do
                    allow_nil? false
                end
                attribute :cover_image_url, :string
                create_timestamp :inserted_at
                update_timestamp :updated_at
            end

        As you might notice you don't see a artist that will be a relationship.

        "Defining Relationships"
            There are different types of relationship 
            has_many: One has Many (Posts)
            belongs_to: One belongs to One (Post)
            has_one: One has One (User Profile)
            many_to_many: Many to Many (tags)

            Not we can head to lib/tunez/music/artist.ex and add in the relationship
                relationships do
                    belongs_to :artist, Tunez.Music.Artist
                end

                relationships do
                    has_many :albums, Tunez.Music.Album do
                end
            
            Now that we have that setup we can generate and set the migration
                mix ash.codegen create_album

            We now have the new DB and the relationship between the artist and albums. We still need to index from the foriegn key. to do that we need to head back to album.ex and set the index?: to true
                postgres do
                # ...
                references do
                    reference :artist, index?: true➤
                end

            This changed the DB so we can now run the code.gen again to create the snapshot and the migrations.
                mix ash.codegen create_album
                mix ash.migrate
            

        "Album Actions"
            As with before we need to set all the actions for the albums. What is great is that we can make sure that we utilize ASH to make sure that you only pull the albums that are related to the artist.
                actions do
                    defaults([:read, :destroy])

                    create :create do
                    accept([:name, :year_released, :cover_image_url, :artist_id])
                    end

                    update :update do
                    accept([:name, :year_released, :cover_image_url])
                    end
                end

            Now we can add in the new resource to the Module Music. Same as before we can add in the album now.
                resource Tunez.Music.Album do
                    define :create_album, action: :create
                    define :get_album_by_id, action: :read, get_by: :id
                    define :update_album, action: :update
                    define :destroy_album, action: :destroy
                end

            They gave us some sample items and albums we want to now run the mix to add them in and then mix seed to get the rest of the albums after uncommenting the right line in the mix.exs.
                mix run priv/repo/seeds/02-albums.exs
                mix seed
                # There might be some issues here with older data being left behind ignore it for now.

        "Creating and Updating Albums"
            Now let's make sure that we have the ability to add and update albums within the site. 
            lib/tunez_web/albums/form_live.ex
                form = Tunez.Music.form_to_create_album()

                # Then we need to add in the validate
                def handle_event("validate", %{"form" => form_data}, socket) do
                    socket =
                    update(socket, :form, fn form ->
                        AshPhoenix.Form.validate(form, form_data)
                    end)
                    {:noreply, socket}
                end

                # Then a save event
                def handle_event("save", %{"form" => form_data}, socket) do
                    case AshPhoenix.Form.submit(socket.assigns.form, params: form_data) do
                    {:ok, _album} ->
                        socket =
                        socket
                        |> put_flash(:info, "Album created successfully")
                        |> push_navigate(to: ~p"/")

                        {:noreply, socket}

                    {:error, form} ->
                        socket =
                        socket
                        |> put_flash(:error, "Could not create album")
                        |> assign(:form, form)

                        {:noreply, socket}
                    end
                end

                # Last a new mount for when we are updating an event
                def mount(%{"id" => album_id}, _session, socket) do
                    album = Tunez.Music.get_album_by_id!(album_id)
                    form = Tunez.Music.form_to_update_album(album)

                    socket =
                    socket
                    |> assign(:form, to_form(form))
                    |> assign(:page_title, "Update Album")

                    {:ok, socket}
                end

            "Using Artist Data on the Album Form"
                Okay so now we need to be sure that we have the right artist for the album that we are creating. We know the ID of the artist so we can now access that and then make sure the we add that to the new form.
                    artist = Tunez.Music.get_artist_by_id!(album.artists_id)
                Then we need to add in the value of the artist to the form on the page
                    <.input name="artist_id" label="Artist" value={@artist.name} disabled />

                    # Then we need to update the new mount to be sure that we have the artist in the socket and then change the first mount to be sure that we have it in there as well
                    |> assign(:artist, artist)
                    mount(%{"artist_id" => artist_id})

                Now let's figure out how to add in the artist to the save but not the update. We can do this but setting the way in which you even get the form done. You can set the forms in the domain. We will use the form to do this.
                    forms do
                        form :create_album, args: [:artist_id]
                    end

    Loading Related Reasource Data
        Now we can make sure that we have the right list of albums within the ShowLive for the artist. We should head to lib/tunez_web/live/artists/show_live.ex then we can agument the artist to also get the album information as well.
            artist = Tunez.Music.get_artist_by_id!(artist_id, load: [:albums])
            # Now change the assign to remove the album line and the general album as well.
            # change the render as well as we no longer have the value for the :album
        
        We have the first index set now we should be able to set the form live for the album as well. lib/tunez_web/live/albums/form_live.ex and now you can set the artist with the load as they are related.
            album = Tunez.Music.get_album_by_id!(album_id, load: [:artist])
            ...
            |> assign(:artist, album.artist)
        
        To go one step further you can even make sure that things are ordered withing the artist album. lib/tunez/music/artist.ex

    Structured Data with Validations and Identities
        Consistant Data with Validations
            We are going to make sure that when we have a year_released its a valid year and even a valid image URL if we have one, we can even be sure that we are making sure we are not adding the same album twice. Let's head over to lib/music/album.ex
                validations do
                    validate(
                    numericality(:year_released,
                        greater_than: 1950,
                        less_than_or_equal_to: &__MODULE__.next_year/0
                    ),
                    where: [present(:year_released)],
                    message: "must be between 1950 and next year"
                    )

                    validate(
                    match(
                        :cover_image_url,
                        ~r"^(https://|/images/).+(\.png|\.jpg)$"
                    ),
                    where: [changing(:cover_image_url)],
                    message: "must start with https:// or /images/"
                    )
                end

        Unique Data with Identities
            Now lets make sure that we have the right validations for the picture URL. This requires a different set of rules to run. This will create an index in the 2 db so that it can check for those values within the DB so we will need to run a command ofter we do that.
                identities do
                    identity(:unique_album_names_per_artist, [:artist_id, :name],
                    message: "already exists for this artist"
                    )
                end

                # Then
                mix ash.codegen add_unique_album_names_per_artist
                mix ash.migrate
            To see what changed head to priv/repo/migrations/[timestamp]_add_unique_album_names_per_artist.exs

    Deleting All of the Things
        Deleting Album Data
            lib/tunez_web/live/artists/show_live.ex
                def handle_event("destroy-album", %{"id" => album_id}, socket) do
                    case Tunez.Music.destroy_album(album_id) do
                    :ok ->
                        socket =
                        socket
                        |> update(:artist, fn artist ->
                            Map.update!(artist, :albums, fn albums ->
                            Enum.reject(albums, &(&1.id == album_id))
                            end)
                        end)
                        |> put_flash(:info, "Album deleted successfully")

                        {:noreply, socket}

                    {:error, error} ->
                        Logger.info("Could not delete album '#{album_id}': #{inspect(error)}")

                        socket =
                        socket
                        |> put_flash(:error, "Could not delete album")

                        {:noreply, socket}
                    end
                end

        Cascading Deletes with AshPostgres
            We can now utilize the belongs_to to make sure that everything is deleted when we delete an artist. We want to delete the related data on delete of the higher level data. Once this is done we will need to codegen and then migrate the database as well
            lib/tunez/music/album.ex
                postgres do
                    table("albums")
                    repo(Tunez.Repo)

                    references do
                    reference(:artist, index?: true, on_delete: :delete)
                    end
                end

                # Then
                mix ash.codegen configure_reference_for_album_artist_id
                mix ash.migrate
            
    Changing Data with Actions
        So much of what we have done so far is setting a lot of data and built-in functions like inserted_at etc, this was all taken care of by ASH. But there is a way to do this manually. Let's go over a few of those now.
        
        Defining an Inline Change
            We want to keep track of any change to an artists name but tracking all previous artists names. lib/tunez/music/artist.ex, as with all the others this is a db change so we need a codegen and then a migration.
                attributes do
                    # ...
                    attribute :previous_names, {:array, :string} do
                        default []
                    end
                    # ...
                end
            
                # Then
                mix ash.codegen add_previous_names_to_artists
                mix ash.migrate

            Okay so we have the column in the db for the previous_names, but that isn't enough as we now need to update the actions to not just use the defualt and then we need to be sure to add the names to the list. Same file also make sure to remove the update from the defaults first the general syntax will look like this.
                update :update do
                    accept([:name, :biography])
                    change(fn changeset, _context -> changeset end)
                end

                # This is the actual code we want.
                actions do
                    defaults([:create, :read, :destroy])
                    default_accept([:name, :biography])

                    update :update do
                    require_atomic?(false)
                    accept([:name, :biography])

                    change(
                        fn changeset, _context ->
                        new_name = Ash.Changeset.get_attribute(changeset, :name)
                        previous_name = Ash.Changeset.get_data(changeset, :name)
                        previous_names = Ash.Changeset.get_data(changeset, :previous_names)

                        names =
                            [previous_name | previous_names]
                            |> Enum.uniq()
                            |> Enum.reject(fn name -> name == new_name end)

                        Ash.Changeset.change_attribute(changeset, :previous_names, names)
                        end,
                        where: [changing(:name)]
                    )
                    end
                end
            
        Defining a Change Module
            Guess what you can do all that with a much easier and faster built-in way!!! lib/tunez/music/changes/update_previous_names.ex, there is not command for this so just create the folder and file and then update the resource.
                defmodule Tunez.Music.Changes.UpdatePreviousNames do
                    use Ash.Resource.Change
                    @impl true
                    def change(changeset, _opts, _context) do
                        new_name = Ash.Changeset.get_attribute(changeset, :name)
                        previous_name = Ash.Changeset.get_data(changeset, :name)
                        previous_names = Ash.Changeset.get_data(changeset, :previous_names)

                        names =
                        [previous_name | previous_names]
                        |> Enum.uniq()
                        |> Enum.reject(fn name -> name == new_name end)

                        Ash.Changeset.change_attribute(changeset, :previous_names, names)
                    end
                end

                # Then change the action in the resource lib/tunez/music/artist.ex
                update :update do
                    require_atomic?(false)
                    accept([:name, :biography])

                    change(Tunez.Music.Changes.UpdatePreviousNames,
                        where: [changing(:name)]
                    )
                end

        Changes Run More Often than You Might Think!
            


Chapter 3: Creating a Better Search UI (59)
    Custom Actions with Arguments

    Dynamically Sorting Artists

    Pagination of Search Results

    No DB field? No Problems, with Calculations

    Relationship Calculations as Aggregates

Chapter 4: Generating APIs Without Writing Code (85)
    Model Your Domain, Derive the Results
    
    Building A JSON REST interface

    Building a GraphQL interface

Chapter 5: Authentication: Who Are You? (107)
    Introducing AshAuthentication

    Setting Up Password Authentication

    Automatic UIs with AshAuthenticationPhoenix

    Setting Up Magic Link Authentication

Chapter 6: Authorization: What Can You Do? (123)
    Introducing Policies

    Authorizing API Access for Authentication

    Assigning Roles to Users

    Writing Policies for Artists
    
    Removing Forbidden Actions from the UI

    Writing Policies for Albums

Chapter 7: Testing Your Application (157)
    What Should We Test?

    Setting Up Data

    Consolidating Test Setup Logic

    Testing Reasources

    Testing Interfaces

Chapter 8: Having Fun With Nested Forms (179)
    Setting Up a Track Resource
    
    Managing Relationships for Related Reasources

    Reorder All of the Tracks!!!

    Automatic Converstions Between Seconds and Minutes

    Adding Track Data to API Responses

Chapter 9: Following Your Favorite Artists (207)
    Modelling with a Many-to-Many Relationship

    Who Do You Follow?

    Spicing Up the Artist Catalog

Chapter 10: Delivering Real-Time Updates with PubSub (225O)
    Notifying Users About New Albums

    Running Actions in Bulk

    Showing Notifications to Users

    Updating Notifications in Real Time
    
    We Need to Talk About Atomics

    Wrapping Everything Up