Chapter 1: Building Our First Resource (1)
    Ash is a set of tools you can use to describe and build the Domain Model. For this we will set up the Tunez Application, install Ash, and build our first resource.

    Getting the Ball Rolling
        This will be a lightweight spotify app (without the music). 

        Setting Up Your Development Environment
            They created a starter github for this project so run
                git clone https://github.com/sevenseacat/tunez
                cd tunez
                mix setup
                mix phx.server

            IF all that works you have everything you need. if not make sure you have asdf and install the files in the .tool-versions

        Welcome to ASH!!
            Now that we know its all working we can now be sure to install an other dependency which is igniter, this is already ready to go from the Tunez project. This will set some new deps and formatter lines as well as fixing the config to be sure to have all the right dependency.
                mix igniter.install ash

            Next we need to set up the post_gres for ash as well. This will do the following add and fetch ash_postgres Hex package, add more autoformatting to config and formatter, update the database to use ASH, update some alias to use ASH instead of Ecto, Generate our first migration, generate the extensions for the config. 
                mix igniter.install ash_postgres

        Resources and Domains
            One of the most important concept is resource in ASH. They are domain model objects (nouns our app revolves around). 

            Related resources are grouped together into Domains. What this means for our app is that we will define several domains for distinct ideas within the app, Music, Album, Artist, Track User, Notifications

            We will set attributes for each. which is data that maps to keys of the resource's struct. 

        Generating the Artist Resource
            First we can create the Artist resource. It will hold the artists name and biography. For this we will use a generator with this command. It will do the following: create a new module Tunez.Music.Artist, a new domain module named Tunez.Music (check out lib/tunez/music/artist.ex) 
                mix ash.gen.resource Tunez.Music.Artist -- extend postgres

            Now that we have the general domain we can now populate it with a table and some attributes
                defmodule Tunez.Music.Artist do
                    use Ash.Resource, otp_app: :tunez, domain: Tunez.Music, data_layer: AshPostgres.DataLayer

                    postgres do
                        table("artists")
                        repo(Tunez.Repo)
                    end
                end

            Then we can set some attributes: first we want a primary key UUID key, time stamp fields (create_timestamp, update_timestamp, name, biography) as you can see below a lot of this can be done with just simple keywords.
                attributes do
                    uuid_primary_key(:id)

                    attribute :name, :string do
                    allow_nil?(false)
                    end

                    attribute(:biography, :string)
                    create_timestamp(:inserted_at)
                    update_timestamp(:updated_at)
                end

            We still need to create the database and there is a command for that (ash.codegen) let's start to look into that now.

        Auto-generating Database Migrations
            If you have run with ecto before you will know that everything needs to stay up to date and if you update a schema or databases independently you will not have an up to date DB. Ash will sidestep this and make sure that everything is done together. `mix ash.codegen' will do the following:
                create snapshots of your current Resources
                compare them to the older snapshot (if existing)
                generate deltas for the changes.

            Let's run that command to create the artists. This created a few files for us, so that we can keep everything up to date: a snapshot priv/resource_snapshots/repo/artists/[*].json, and the migration for the artist resource priv/repo/migrations/[*]_create_artists.ex
                mix ash.codegen create_artists

            Let's check out the migration that was just created.
                def up do
                    create table(:artists, primary_key: false) do
                    add :id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true
                    add :name, :text, null: false
                    add :biography, :text

                    add :inserted_at, :utc_datetime_usec,
                        null: false,
                        default: fragment("(now() AT TIME ZONE 'utc')")

                    add :updated_at, :utc_datetime_usec,
                        null: false,
                        default: fragment("(now() AT TIME ZONE 'utc')")
                    end
                end

                def down do
                    drop table(:artists)
                end
            
            Looks just like something that you would create doing it all yourself. This all came from the schema we created and then the Ash generator. We can now migrate with the mix ash command.
                mix ash.migrate

    Oh, CRUD! - Defining Basic Actions
        Remember that CRUD is:
            Create
            Read
            Update
            Delete

        We will need to define those actions within our database. Remembering that everything that we want to do can be done within the artists.ex file simply add in an action block and go.

        Defining a Create Action
            All actions require a type (create, read, update, destroy) I will put all the changes to the module below but there will be a few thing to look for. As of right now we just the action and an atom to call it with, and then what it will accept

              actions do
                create :create do
                accept([:name, :biography])
            end
        
        Creating Records via a Changeset
            Create a changeset and then pass it to a process to add it.
                iex -S mix
                Tunez.Music.Artist
                |> Ash.Changeset.for_create(:create, %{
                name: "Valkyrie's Fury",
                biography: "A power metal band hailing from Tallinn, Estonia"
                })
                |> Ash.create()

            Now we can see if it did in-fact work with a psql command
                psql tunez_dev
                tunez_dev=# select * from artists;
                    -[ RECORD 1 ]----------------------------------------------
                    id | [uuid]
                    name | Valkyrie's Fury
                    biography | A power metal band hailing from Tallinn, Estonia
                    inserted_at | [now]
                    updated_at | [now]
            
            We can now check to see if you can do some other creates with or without name etc.

        Creating Records via a Code Interface
            So we want to now use a Domain to interact with a database so that we can have lower level (resources) work done through a domain. Let's head to the file /lib/tunez/music.ex. This is a domain.
                resources do
                    resource Tunez.Music.Artist do
                        define :create_artist, action: :create
                    end
                end

            With this in place we can no interact with the create_artist function.
                iex(5)> h Tunez.Music.create_artist

                 def create_artist(params \\ nil, opts \\ nil)                  

                Calls the create action on Tunez.Music.Artist.

                # Inputs

                • name
                • biography

            Okay so now we can use this syntax to create an artist from the music module.
                iex > Tunez.Music.create_artist(%{
                name: "Valkyrie's Fury",
                biography: "A power metal band hailing from Tallinn, Estonia"
                })    

            Let's quickly look at the seed logic in the mix.exs so that we can see what kind of work is done with the `mix seed` command.
                  defp aliases do
                    [
                    setup: ["deps.get", "ash.setup", "assets.setup", "assets.build", "run priv/repo/seeds.exs"],
                    "ecto.setup": ["ecto.create", "ecto.migrate"],
                    seed: [
                        "run priv/repo/seeds/01-artists.exs",

            With this line uncommented we can run the mix seed to create some artists.
                mix seed

        Defining a Read Action
            now we can add in the read action to the resource Artist
                read :read do
                    primary?(true)
                end

            Then add it to the music Domain
                define :read_artist, action: :read

                iex> Tunez.Music.read_artists()

            ``Manually Reading Records Via a Query``
                This will now work for us. Right now as we didn't set some params for the read we will just pull everything the other way is to create a temp artist struct and then pass some queries to it. The basic idea is: create basic query > pipe through functions to add params > Pass to Ash for processing, see below.
                    iex(2)> Tunez.Music.Artist
                    Tunez.Music.Artist
                    iex(3)> |> Ash.Query.for_read(:read)
                    #Ash.Query<resource: Tunez.Music.Artist, action: :read>
                    Then you can pipe that query into Ash’s query functions like sort and limit. The
                    query keeps getting the extra conditions added to it, but it isn’t yet being run
                    in the database.
                    iex(4)> |> Ash.Query.sort(name: :asc)
                    #Ash.Query<resource: Tunez.Music.Artist, action: :read, sort: [name: :asc]>
                    iex(5)> |> Ash.Query.limit(1)
                    #Ash.Query<resource: Tunez.Music.Artist, action: :read, sort: [name: :asc],
                    limit: 1>
                    Then, when it’s time to go, Ash can call it and return the data you requested,
                    with all conditions applied:
                    iex(6)> |> Ash.read()
                    SELECT a0."id", a0."name", a0."biography", a0."inserted_at", a0."updated_at"
                    FROM "artists" AS a0 ORDER BY a0."name" LIMIT $1 [1]
                    {:ok, [#Tunez.Music.Artist<...>]}

            `Reading a Single Record by Primary Key` 
                Right now again if we were to try a read it will retrieve everything but there is a simple way to use a resource and be able to pass a param and get a record by that param. Head back to the music domain and then add this.
                    define :get_artist_by_id, action: :read, get_by: :id

        Defining an Update Action
            Now we can add in an update. Remember that we now just need to add in the action and then add it to a module.
                update :update do
                    accept [:name, :biography]
                end

                define :update_artist, action: :update

            How do we use this? Well we need an artist and then we need to send it the information that will be updated.
                iex(3)> artist = Tunez.Music.get_artist_by_id!("an-artist-id")
                #Tunez.Music.Artist<id: "an-artist-id", ...>
                Now we can either use the code interface we added or create a changeset and
                apply it, as we did for create.
                iex(4)> # Via the code interface
                iex(5)> Tunez.Music.update_artist(artist, %{name: "Hello"})
                UPDATE "artists" AS a0 SET "updated_at" = (CASE WHEN $1::text !=
                a0."name"::text THEN $2::timestamp ELSE a0."updated_at"::timestamp END)
                ::timestamp, "name" = $3::text WHERE (a0."id"::uuid = $4::uuid) RETURNING
                a0."id", a0."name", a0."biography", a0."inserted_at", a0."updated_at"
                ["Hello", [now], "Hello", "an-artist-id"]
                {:ok, #Tunez.Music.Artist<id: "an-artist-id", name: "Hello", ...>}
                iex(6)> # Or via a changeset
                iex(7)> artist
                |> Ash.Changeset.for_update(:update, %{name: "World"})
                |> Ash.update()
                «an almost-identical SQL statement»
                {:ok, #Tunez.Music.Artist<id: "an-artist-id", name: "World", ...>}

        Defining a Destroy Action
            Now we simply need to add in a delete (destroy) and we have at least the start of CRUD
                destroy :destroy do
                end

                define :destroy_artist, action: :destroy

            How we will use it is slightly different as we would like to use a changeset
                ex(3)> artist = Tunez.Music.get_artist_by_id!("the-artist-id")
                #Tunez.Music.Artist<id: "an-artist-id", ...>
                iex(4)> # Via the code interface
                iex(5)> Tunez.Music.destroy_artist(artist)
                DELETE FROM "artists" AS a0 WHERE (a0."id" = $1) ["the-artist-id"]
                :ok
                iex(6)> # Or via a changeset
                iex(7)> artist
                |> Ash.Changeset.for_destroy(:destroy)
                |> Ash.destroy()
                DELETE FROM "artists" AS a0 WHERE (a0."id" = $1) ["the-artist-id"]
                :ok

        Default Actions
            Now that we know how to setup some of the actions we can just use a module and set some default actions as ASH is set to just use CRUD off the bat. Let's go to the artist.ex resource and replace everything with this.
                defaults [:create, :read, :update, :destroy]
                default_accept [:name, :biography]

            What is great about this is that the normal default here add in a lot of functionality that you would want (or and not use) like pagination etc.

    Integrating Actions into LiveViews
        Now that we have the database and some dummy entries we can try to actually look at the database and teh Phoenix integration.
            mix phx.server
            # Then head to localhost:4000 and check it out.
        
        What you are seeing on the main page is the module in lib/tunez_web/live/artist/index_live.ex. They set us up with some dummy artist but we can replace the artists with a call to the database.
            artists = Tunez.Music.read_artists!() # Notice the ! this will just return the artists not a condition as well

        Viewing an Artist Profile
            Clicking on an image will take you to the profile page using TunezWeb.Artists.ShowLive, again we see that there is some default data here and we can now change the default with get_artist_by_id! (again the !)
                def handle_params(%{"id" => artist_id} =  params, _url, socket) do
                    artist = Tunez.Music.get_artist_by_id!(artist_id)
                    ...
                end
        
        Creating Artists with AshPhoenix.Form
            In a normal way we would define a changeset and then cast that changeset with the Repo.insert{} like below with ash there is an other way.
            In code, the changeset function might look something like this:
                defmodule Tunez.Music.Artist do
                    def changeset(artist, attrs) do
                        artist
                        |> cast(attrs, [:name, :biography])
                        |> validate_required([:name])
                    end
            And the context module that uses it might look like this:
                defmodule Tunez.Music do
                    def create_artist(attrs \\ %{}) do
                        %Artist{}
                        |> Artist.changeset(attrs)
                        |> Repo.insert()
                    end

            "Hello, AshPhoenix"
                AshPhoenix is a core library that can do a few things but the main purpose is forms.
                    mix igniter.install ash_phoenix

            "A Form for an Action"
                This created a form for us that we can use right away. Lets try it out. 
                    iex -S mix
                    iex(1)> form = AshPhoenix.Form.for_create(Tunez.Music.Artist, :create)
                    #AshPhoenix.Form<
                    resource: Tunez.Music.Artist,
                    action: :create,
                    type: :create,
                    params: %{},
                    source: #Ash.Changeset<
                    domain: Tunez.Music,
                    action_type: :create,
                    action: :create,
                    attributes: %{},
                    ...

                    iex(2)> AshPhoenix.Form.validate(form, %{name: "Best Band Ever"})
                    #AshPhoenix.Form<
                    resource: Tunez.Music.Artist,
                    action: :create,
                    type: :create,
                    params: %{name: "Best Band Ever"},
                    source: #Ash.Changeset<
                    domain: Tunez.Music,
                    action_type: :create,
                    action: :create,
                    attributes: %{name: "Best Band Ever"},
                    relationships: %{},
                    errors: [],
                    data: %Tunez.Music.Artist{...},
                    valid?: true
                    >,
                    ...

                    iex(5)> AshPhoenix.Form.submit(form, params: %{name: "Best Band Ever"})
                    INSERT INTO "artists" ("id","name","inserted_at","updated_at") VALUES
                    ($1,$2,$3,$4) RETURNING "updated_at","inserted_at","biography","name","id"
                    [[uuid], "Best Band Ever", [timestamp], [timestamp]]
                    {:ok,
                    %Tunez.Music.Artist{
                    id: [uuid],
                    name: "Best Band Ever",
                    ...

                As you can see we have some built in functions that will create and then validate as well as insert the new band into the database. With this taken care of we can now try to add the domain to the Domain so that we can now use the form to do all the above

            "Using the AshPhoenix Domain Extension"
                The functionality that we are using atm is to call the :create atom and that feels a bit problematic for what we have already done. With that being said we can now add the AshPhoenix extension to the Music Domain to leverage the new form.
                    defmodule Tunez.Music do
                        use Ash.Domain, otp_app: :tunez, extensions: [AshPhoenix]
                        # ...    
                
                Lets try out the new way of doing things. Now we can simply append the form_to to any function and it will create a form to do that thing. Keep in mind that you will need to have the extension within the module.
                    iex(5)> AshPhoenix.Form.for_create(Tunez.Music.Artist, :create)
                    #AshPhoenix.Form<resource: Tunez.Music.Artist, action: :create, ...>
                    iex(6)> Tunez.Music.form_to_create_artist()
                    #AshPhoenix.Form<resource: Tunez.Music.Artist, action: :create, ...>

            "Integrating a Form into a LiveView"
                We can now go to lib/tunez/live/artists/form_live.ex this is where you would go to create a new artist form.
                    form = Tunez.Music.form_to_create_artist()

                Its really that simple. So long as you have some form of the html for the render you will not have access to the form for anything that has the extension installed. There is a built in validate event that is currently not doing anything so we should now define it.
                    def handle_event("validate", %{"form" => form_data}, socket) do
                        socket =
                        update(socket, :form, fn form ->
                            AshPhoenix.Form.validate(form, form_data)
                        end)
                        {:noreply, socket}
                    end

                We now need to take care of the submit there is also a way to do that as well. Keep in mind that you are calling the "save" event when you save the form. It is already defined below the render so lets flesh it out. You will need to take care of 2 events a valid submit and an issue both of those should have some sort of flash message as well as put you back into a page.
                    def handle_event("save", %{"form" => form_data}, socket) do
                        case AshPhoenix.Form.submit(socket.assigns.form, params: form_data) do
                        {:ok, artist} ->
                            socket =
                            socket
                            |> put_flash(:info, "Artist saved successfully")
                            |> push_navigate(to: ~p"/artists/#{artist}")

                            {:noreply, socket}

                        {:error, form} ->
                            socket =
                            socket
                            |> put_flash(:error, "Could not save artist data")
                            |> assign(:form, form)

                            {:noreply, socket}
                        end
                    end

                Great now we can add an artist but we don't have a way to edit and then delete.

        Updating Artists with the same Code
            Remember that the update and create were very similar function calls where one just needs an artist id to be called as well. Also keep in mind that once you are looking at an artist you will have the artist within the params of the page. So so long as you have those values and functions you can create or edit an artist. What is great is that we can pattern match to an existing artist in the mount so that we can pull the data for the artist and then do an update.
                def mount(%{"id" => artist_id}, _session, socket) do
                    artist = Tunez.Music.get_artist_by_id!(artist_id)
                    form = Tunez.Music.form_to_update_artist(artist)

                    socket =
                    socket
                    |> assign(:form, to_form(form))
                    |> assign(:page_title, "Update Artist")

                    {:ok, socket}
                end

            Simple but keep in mind that you are setting the form to have the existing data for the artist then you can edit with an update.
                

        Deleting Artists Data
            This is the destroy action that we created earlier. We now need to head to the show_live.ex in order to create this event. Looking at the show_live.ex we see that the delete artist button will call the delete event. So in order to do this we need to pass the artists id and then run the destroy function to do so.
                def handle_event("destroy-artist", _params, socket) do
                    case Tunez.Music.destroy_artist(socket.assigns.artist) do
                    :ok ->
                        socket =
                        socket
                        |> put_flash(:info, "Artist deleted successfully")
                        |> push_navigate(to: ~p"/")

                        {:noreply, socket}

                    {:error, error} ->
                        Logger.info("Could not delete artist '#{socket.assigns.artist.id}':#{inspect(error)}")

                        socket =
                        socket
                        |> put_flash(:error, "Could not delete artist")

                        {:noreply, socket}
                    end
                end

    That is it we now have forms for creating an artist editing an artists and even the functionality for deleting an artist. There is so much that you can do here to make this easier but we will more on to more functionality.
 
Chapter 2: Extending Resources with Business Logic (33)
    Resources and Relationships
        We have created a single resource now lets create an album resource. 
            mix ash.gen.resource Tunez.Music.Album --extend postgres

        We now have some new files, we want to add these things to the DB:
            Artist, Album name, Year released, Image

        Let's head over to lib/tunez/music/album.ex
            attributes do
                uuid_primary_key :id
                attribute :name, :string do
                    allow_nil? false
                end
                attribute :year_released, :integer do
                    allow_nil? false
                end
                attribute :cover_image_url, :string
                create_timestamp :inserted_at
                update_timestamp :updated_at
            end

        As you might notice you don't see a artist that will be a relationship.

        "Defining Relationships"
            There are different types of relationship 
            has_many: One has Many (Posts)
            belongs_to: One belongs to One (Post)
            has_one: One has One (User Profile)
            many_to_many: Many to Many (tags)

            Not we can head to lib/tunez/music/artist.ex and add in the relationship
                relationships do
                    belongs_to :artist, Tunez.Music.Artist
                end

                relationships do
                    has_many :albums, Tunez.Music.Album do
                end
            
            Now that we have that setup we can generate and set the migration
                mix ash.codegen create_album

            We now have the new DB and the relationship between the artist and albums. We still need to index from the foreign key. to do that we need to head back to album.ex and set the index?: to true
                postgres do
                # ...
                references do
                    reference :artist, index?: true
                end

            This changed the DB so we can now run the code.gen again to create the snapshot and the migrations.
                mix ash.codegen create_album
                mix ash.migrate
            

        "Album Actions"
            As with before we need to set all the actions for the albums. What is great is that we can make sure that we utilize ASH to make sure that you only pull the albums that are related to the artist.
                actions do
                    defaults([:read, :destroy])

                    create :create do
                    accept([:name, :year_released, :cover_image_url, :artist_id])
                    end

                    update :update do
                    accept([:name, :year_released, :cover_image_url])
                    end
                end

            Now we can add in the new resource to the Module Music. Same as before we can add in the album now.
                resource Tunez.Music.Album do
                    define :create_album, action: :create
                    define :get_album_by_id, action: :read, get_by: :id
                    define :update_album, action: :update
                    define :destroy_album, action: :destroy
                end

            They gave us some sample items and albums we want to now run the mix to add them in and then mix seed to get the rest of the albums after uncommenting the right line in the mix.exs.
                mix run priv/repo/seeds/02-albums.exs
                mix seed
                # There might be some issues here with older data being left behind ignore it for now.

        "Creating and Updating Albums"
            Now let's make sure that we have the ability to add and update albums within the site. 
            lib/tunez_web/live/albums/form_live.ex
                form = Tunez.Music.form_to_create_album()

                # Then we need to add in the validate
                def handle_event("validate", %{"form" => form_data}, socket) do
                    socket =
                    update(socket, :form, fn form ->
                        AshPhoenix.Form.validate(form, form_data)
                    end)
                    {:noreply, socket}
                end

                # Then a save event
                def handle_event("save", %{"form" => form_data}, socket) do
                    case AshPhoenix.Form.submit(socket.assigns.form, params: form_data) do
                    {:ok, _album} ->
                        socket =
                        socket
                        |> put_flash(:info, "Album created successfully")
                        |> push_navigate(to: ~p"/")

                        {:noreply, socket}

                    {:error, form} ->
                        socket =
                        socket
                        |> put_flash(:error, "Could not create album")
                        |> assign(:form, form)

                        {:noreply, socket}
                    end
                end

                # Last a new mount for when we are updating an event
                def mount(%{"id" => album_id}, _session, socket) do
                    album = Tunez.Music.get_album_by_id!(album_id)
                    form = Tunez.Music.form_to_update_album(album)

                    socket =
                    socket
                    |> assign(:form, to_form(form))
                    |> assign(:page_title, "Update Album")

                    {:ok, socket}
                end

            "Using Artist Data on the Album Form"
                Okay so now we need to be sure that we have the right artist for the album that we are creating. We know the ID of the artist so we can now access that and then make sure the we add that to the new form.
                    artist = Tunez.Music.get_artist_by_id!(album.artists_id)
                Then we need to add in the value of the artist to the form on the page
                    <.input name="artist_id" label="Artist" value={@artist.name} disabled />

                    # Then we need to update the new mount to be sure that we have the artist in the socket and then change the first mount to be sure that we have it in there as well
                    |> assign(:artist, artist)
                    mount(%{"artist_id" => artist_id})

                Now let's figure out how to add in the artist to the save but not the update. We can do this but setting the way in which you even get the form done. You can set the forms in the domain. We will use the form to do this.
                    forms do
                        form :create_album, args: [:artist_id]
                    end

    Loading Related Resource Data
        Now we can make sure that we have the right list of albums within the ShowLive for the artist. We should head to lib/tunez_web/live/artists/show_live.ex then we can augment the artist to also get the album information as well.
            artist = Tunez.Music.get_artist_by_id!(artist_id, load: [:albums])
            # Now change the assign to remove the album line and the general album as well.
            # change the render as well as we no longer have the value for the :album
        
        We have the first index set now we should be able to set the form live for the album as well. lib/tunez_web/live/albums/form_live.ex and now you can set the artist with the load as they are related.
            album = Tunez.Music.get_album_by_id!(album_id, load: [:artist])
            ...
            |> assign(:artist, album.artist)
        
        To go one step further you can even make sure that things are ordered withing the artist album. lib/tunez/music/artist.ex

    Structured Data with Validations and Identities
        Consistent Data with Validations
            We are going to make sure that when we have a year_released its a valid year and even a valid image URL if we have one, we can even be sure that we are making sure we are not adding the same album twice. Let's head over to lib/music/album.ex
                validations do
                    validate(
                    numerically(:year_released,
                        greater_than: 1950,
                        less_than_or_equal_to: &__MODULE__.next_year/0
                    ),
                    where: [present(:year_released)],
                    message: "must be between 1950 and next year"
                    )

                    validate(
                    match(
                        :cover_image_url,
                        ~r"^(https://|/images/).+(\.png|\.jpg)$"
                    ),
                    where: [changing(:cover_image_url)],
                    message: "must start with https:// or /images/"
                    )
                end

        Unique Data with Identities
            Now lets make sure that we have the right validations for the picture URL. This requires a different set of rules to run. This will create an index in the 2 db so that it can check for those values within the DB so we will need to run a command ofter we do that.
                identities do
                    identity(:unique_album_names_per_artist, [:artist_id, :name],
                    message: "already exists for this artist"
                    )
                end

                # Then
                mix ash.codegen add_unique_album_names_per_artist
                mix ash.migrate
            To see what changed head to priv/repo/migrations/[timestamp]_add_unique_album_names_per_artist.exs

    Deleting All of the Things
        Deleting Album Data
            lib/tunez_web/live/artists/show_live.ex
                def handle_event("destroy-album", %{"id" => album_id}, socket) do
                    case Tunez.Music.destroy_album(album_id) do
                    :ok ->
                        socket =
                        socket
                        |> update(:artist, fn artist ->
                            Map.update!(artist, :albums, fn albums ->
                            Enum.reject(albums, &(&1.id == album_id))
                            end)
                        end)
                        |> put_flash(:info, "Album deleted successfully")

                        {:noreply, socket}

                    {:error, error} ->
                        Logger.info("Could not delete album '#{album_id}': #{inspect(error)}")

                        socket =
                        socket
                        |> put_flash(:error, "Could not delete album")

                        {:noreply, socket}
                    end
                end

        Cascading Deletes with AshPostgres
            We can now utilize the belongs_to to make sure that everything is deleted when we delete an artist. We want to delete the related data on delete of the higher level data. Once this is done we will need to codegen and then migrate the database as well
            lib/tunez/music/album.ex
                postgres do
                    table("albums")
                    repo(Tunez.Repo)

                    references do
                    reference(:artist, index?: true, on_delete: :delete)
                    end
                end

                # Then
                mix ash.codegen configure_reference_for_album_artist_id
                mix ash.migrate
            
    Changing Data with Actions
        So much of what we have done so far is setting a lot of data and built-in functions like inserted_at etc, this was all taken care of by ASH. But there is a way to do this manually. Let's go over a few of those now.
        
        Defining an Inline Change
            We want to keep track of any change to an artists name but tracking all previous artists names. lib/tunez/music/artist.ex, as with all the others this is a db change so we need a codegen and then a migration.
                attributes do
                    # ...
                    attribute :previous_names, {:array, :string} do
                        default []
                    end
                    # ...
                end
            
                # Then
                mix ash.codegen add_previous_names_to_artists
                mix ash.migrate

            Okay so we have the column in the db for the previous_names, but that isn't enough as we now need to update the actions to not just use the default and then we need to be sure to add the names to the list. Same file also make sure to remove the update from the defaults first the general syntax will look like this.
                update :update do
                    accept([:name, :biography])
                    change(fn changeset, _context -> changeset end)
                end

                # This is the actual code we want.
                actions do
                    defaults([:create, :read, :destroy])
                    default_accept([:name, :biography])

                    update :update do
                    require_atomic?(false)
                    accept([:name, :biography])

                    change(
                        fn changeset, _context ->
                        new_name = Ash.Changeset.get_attribute(changeset, :name)
                        previous_name = Ash.Changeset.get_data(changeset, :name)
                        previous_names = Ash.Changeset.get_data(changeset, :previous_names)

                        names =
                            [previous_name | previous_names]
                            |> Enum.uniq()
                            |> Enum.reject(fn name -> name == new_name end)

                        Ash.Changeset.change_attribute(changeset, :previous_names, names)
                        end,
                        where: [changing(:name)]
                    )
                    end
                end
            
        Defining a Change Module
            Guess what you can do all that with a much easier and faster built-in way!!! lib/tunez/music/changes/update_previous_names.ex, there is not command for this so just create the folder and file and then update the resource.
                defmodule Tunez.Music.Changes.UpdatePreviousNames do
                    use Ash.Resource.Change

                    @impl true
                    def change(changeset, _opts, _context) do
                        Ash.Changeset.before_action(changeset, fn changeset ->
                        new_name = Ash.Changeset.get_attribute(changeset, :name)
                        previous_name = Map.get(changeset.data, :name)
                        previous_names = Map.get(changeset.data, :previous_names) || []

                        names =
                            [previous_name | previous_names]
                            |> Enum.uniq()
                            |> Enum.reject(&(&1 == new_name))

                        Ash.Changeset.change_attribute(changeset, :previous_names, names)
                        end)
                    end
                end

                # Then change the action in the resource lib/tunez/music/artist.ex
                update :update do
                    require_atomic?(false)
                    accept([:name, :biography])

                    change(Tunez.Music.Changes.UpdatePreviousNames,
                        where: [changing(:name)]
                    )
                end

        Changes Run More Often than You Might Think!
            Keep in mind that any time you: 
                Building the initial form
                Authorization checks
                Every validation check
                When submitting the form
            You are running a change. As such you should wrap them in hooks such as Ash.Changeset.before_action or Ash.Changeset.after_action. So the UpdatePreviousNames would look like this.
                def change(changeset, _opts, _context) do
                    Ash.Changeset.before_action(changeset, fn ->
                    # The code previously in the body of the function
                    # It can still use any `opts` or `context` passed in to the top-level
                    # change function, as well
                    new_name = Ash.Changeset.get_attribute(changeset, :name)
                    previous_name = Ash.Changeset.get_data(changeset, :name)
                    previous_names = Ash.Changeset.get_data(changeset, :previous_names)

                    names =
                        [previous_name | previous_names]
                        |> Enum.uniq()
                        |> Enum.reject(fn name -> name == new_name end)

                    Ash.Changeset.change_attribute(changeset, :previous_names, names)
                    end)
                end
            This is going to run right before the action is completed that calls it, in our case the change name.
        
        Rendering the Previous Names in the UI
            This will be quick so just add this to the code and you will see the older names.
            lib/tunez_web/live/artists/show_live.ex
            <.header>
                <.h1>...</.h1>
                <:subtitle :if={@artist.previous_names != []}>
                    formerly known as: {Enum.join(@artist.previous_names, ", ")}
                </:subtitle>
                ...
            </.header>


Chapter 3: Creating a Better Search UI (59)
    Custom Actions with Arguments
        We want to implement a way to search for an artist and even a piece of information with a string. Something like.
            iex> Tunez.Music.search_artists("fur")
            {:ok, [%Tunez.Music.Artist{name: "Valkyrie's Fury"}, ...]}

            Designing a Search Action
                Lets head over to the lib/tunez/music/artist.ex and add in a read :search action. We can make it take some parameters and set some constraints and even set a default.
                    read :search do
                        argument(:query, :ci_string) do
                            constraints(allow_empty?: true)
                            default("")
                        end

                        filter(expr(contains(name, ^arg(:query))))
                    end

            Filters with Expressions
                Lets go over that last line of code and see it in action. When we run the iex session be sure to add in "require Ash.Query"
                    iex -S mix
                    iex(1)> require Ash.Query
                    Ash.Query
                    iex(2)> Ash.Query.filter(Tunez.Music.Album, year_released == 2024)
                    #Ash.Query<resource: Tunez.Music.Album,
                    filter: #Ash.Filter<year_released == 2024>>
                    iex(3)> |> Ash.read()
                    SELECT a0."id", a0."name", a0."inserted_at", a0."updated_at",
                    a0."year_released", a0."artist_id", a0."cover_image_url" FROM "albums" AS
                    a0 WHERE (a0."year_released"::bigint = $1::bigint) [2024]
                    {:ok, [%Tunez.Music.Album{year_released: 2024, ...}, ...]}

                Now the filter is not limited to just == you can use an where you just need to wrap it in a call to expr. 
                    ex(4)> Tunez.Music.Artist
                    Tunez.Music.Artist
                    iex(5)> |> Ash.Query.for_read(:search, %{query: "co"})
                    #Ash.Query<
                    resource: Tunez.Music.Artist,
                    arguments: %{query: #Ash.CiString<"co">},
                    filter: #Ash.Filter<contains(name, #Ash.CiString<"co">)>
                    >
                    iex(6)> |> Ash.read()
                    SELECT a0."id", a0."name", a0."biography", a0."previous_names",
                    a0."inserted_at", a0."updated_at" FROM "artists" AS a0 WHERE
                    (a0."name"::text ILIKE $1) ["%co%"]
                    {:ok, [#Tunez.Music.Artist<name: "Crystal Cove", ...>, ...]}

                This did what we want by allowing case-insensitive substring matches.

            Speeding Things Up with Custom Database Indexes
                This is a very non performant way of doing thing so we can add in a GIN index to help on the name column. First we need to enable it and then start to use it. Let's get it installed first.
                    lib/tunes/repo.ex
                    @impl true
                    def installed_extensions do
                        # Add extensions here, and the migration generator will install them.
                        ["ash-functions", "pg-trgm"]
                    end
                
                Then head to lib/tunez/music/artist.ex
                    postgres do
                        table("artists")
                        repo(Tunez.Repo)

                        custom_indexes do
                        index("name gin_trgm_ops", name: "artists_name_trgm_index", using: "GIN")
                        end
                    end
                
                Normally AshPostgres will generate the names of indexes by itself from the fields but since we are creating a custom index. Now run the new the new migrations.
                    mix ash.codegen add_gin_index_for_artist_name_search
                    mix ash.migrate

            Integrating Search into the UI
                Now lets integrate it into out first catalog.
                "A Code Interface with Arguments"
                    lib/tunez/music.ex
                    resource Tunez.Music.Artist do
                        # ...
                        define :search_artists, action: :search, args: [:query]
                    end

                    We set a new resource that we can use in music domain. We can now try it out in an iex session.
                        iex(1)> h Tunez.Music.search_artists
                            def search_artists(query, params \\ nil, opts \\ nil)
                        Calls the search action on Tunez.Music.Artist.

                "Searching from the Catalog"
                    We want to be able to copy and replicate the results that we get from the site so we need to be able to get to them with URLs. Lets head over to lib/tunez_web/live/artists/index_live.ex: This is what it looks like without a param in the URL
                        def handle_params(_params, _url, socket) do
                            artists = Tunez.Music.read_artists!()
                            socket =
                                socket
                                |> assign(:artists, artists)
                                # ...

                        # Lets pattern match the param and set some values in the query.
                        def handle_params(params, _url, socket) do
                            query_text = Map.get(params, "q", "")
                            artists = Tunez.Music.search_artists!(query_text)
                            socket =
                                socket
                                |> assign(:query_text, query_text)
                                |> assign(:artists, artists)
                                # ...
                    
                    Now we can add in box to the header to be able to search with a bar.
                        <.header responsive={false}>
                            <.h1>Artists</.h1>
                            <:action>
                                <.search_box query={@query_text} method="get"
                                    data-role="artist-search" phx-submit="search" />
                            </:action>
                            <:action>
                                <.button_link
                                    # ...

    Dynamically Sorting Artists
        Now that we have the search set we can now move onto the sort so a user can get the right artist faster.

        Letting Users Set a Sort Method
            Start with the UI then we can implement the needed code. lib/tunez_web/live/artists/index_live.ex
                <.header responsive={false}>
                    <.h1>Artists</.h1>
                    <:action><.sort_changer selected={@sort_by} /></:action>
                    ...

                # Now lets set the new param in the handle_params
                def handle_params(params, _url, socket) do
                    sort_by = nil
                    # ...

                    socket =
                        socket
                        |> assign(:sort_by, sort_by)
                        # ...

                # The sort changer is below and it will call the handle_event for "change-sort". Now let's add in the validation
                def handle_params(params, _url, socket) do
                    sort_by = Map.get(params, "sort_by") |> validate_sort_by()
                    # ...

        The Base Query for a Read Action
            We set up the UI now lets implement it. Here is the basic way in which we would run a query. Notice what we are asking in this read. We are setting the way in which we are sorting we need to implement that ourselves.
                iex(2)> Tunez.Music.Artist
                Tunez.Music.Artist
                iex(3)> |> Ash.Query.for_read(:read)
                Ash.Query<resource: Tunez.Music.Artist>
                iex(4)> |> Ash.Query.sort(name: :asc)
                #Ash.Query<resource: Tunez.Music.Artist, sort: [name: :asc]>
                iex(5)> |> Ash.Query.limit(1)
                #Ash.Query<resource: Tunez.Music.Artist, sort: [name: :asc], limit: 1>
                iex(6)> |> Ash.read()
                SELECT a0."id", a0."name", a0."biography", a0."inserted_at", a0."updated_at"
                FROM "artists" AS a0 ORDER BY a0."name" LIMIT $1 [1]
                {:ok, [#Tunez.Music.Artist<...>]}

        Using sort_input for Succinct yet Expressive Sorting
            Normally you can use sort and then set things like name: :asc, inserted_at: :desc you can even test this out.
                iex(6)> Tunez.Music.search_artists("the", [query: [sort: [name: :asc]]])
                    {:ok,
                    [
                        #Tunez.Music.Artist<name: "Nights in the Nullarbor", ...>,
                        #Tunez.Music.Artist<name: "The Lost Keys", ...>
                    ]}
            
            But we can use sort_input a bit differently. So we can just set a list of key words and the it will pull from those. But in order to utilize this we need to make some changes to the resource, in order to use it, sort_input will need PUBLIC attributes. Let's head over to lib/tunez/music/artist.ex
                attributes do
                    # ...
                    attribute :name, :string do
                        allow_nil?(false)
                        public?(true)
                    end

                    # ...
                    create_timestamp(:inserted_at, public?: true)
                    update_timestamp(:updated_at, public?: true)
                end

                Head into an iex and test this out
                iex(6) > Tunez.Music.search_artists("the", [query: [sort_input: "-name"]])
                [debug] QUERY OK source="artists" db=0.9ms queue=0.5ms idle=1270.9ms
                SELECT a0."id", a0."name", a0."biography", a0."inserted_at", a0."previous_names", a0."updated_at" FROM "artists" AS a0 WHERE (a0."name"::text ILIKE $1) ORDER BY a0."name" DESC ["%the%"]
                ↳ anonymous fn/3 in AshPostgres.DataLayer.run_query/2, at: lib/data_layer.ex:827
                {:ok,
                [
                %Tunez.Music.Artist{
                    id: "f6c77d42-2c90-4654-853f-37c071d9ef87",
                    name: "The Lost Keys",
                    previous_names: [],
                    biography: "The Lost Keys are a blues rock band hailing from New Orleans, Louisiana, formed in 2014. The band comprises a group of musicians who found each other through...}
                ]
                }

            Now we can leverage this into a single string of values that can be added into the params. lib/tunez_web/live/artists/index_live.ex
                def handle_params(params, _url, socket) do
                    # ...
                    artists = Tunez.Music.search_artists!(query_text, query: [sort_input: sort_by])

                # Now just a quick tweak to the sort_options
                defp sort_options do
                    [
                        {"recently updated", "-updated_at"},
                        {"recently added", "-inserted_at"},
                        {"name", "name"}
                    ]
                end
            
        We now can change the way in-which we sort the data and it will update on the URL as well so you can copy and paste a URL to your friends.
            
    Pagination of Search Results
        Now lets add in some pagination so that you can also be sure to have everything in a more concise manner.

        Adding Pagination Support to the search Action
            First lets head to lib/tunez/music/artist.ex and add in an other part for the search.
                read :search do
                # ...
                    pagination offset?: true, default_limit: 12
                end

            It can support both types if pagination amount of records or after record x. You can test it out as well. 
                iex(1)> Tunez.Music.search_artists!("cove")
                    #Ash.Page.Offset<
                    results: [#Tunez.Music.Artist<name: "Crystal Cove", ...>],
                    limit: 12,
                    offset: 0,
                    count: nil,
                    more?: false,
                    ...
                >
            
        Showing Paginated Data in the Catalog
            So now we need to understand what page we are on and the search artists will not have that information. So we can leverage that with the handle_params lib/tunez/live/artists/index_live.ex since it now will return a struct for the page you are receiving not and "artist" 
                def handle_params(params, _url, socket) do
                    # ...
                    page = Tunez.Music.search_artists!(query_text, query: [sort_input: sort_by])
                    socket =
                        socket
                        |> assign(:query_text, query_text)
                        |> assign(:page, page)
                        # ...

                # Now lets set the render and html code.
                <div :if={@page.results == []} class="p-8 text-center">
                    <.icon name="hero-face-frown" class="w-32 h-32 bg-gray-300" />
                    <br /> No artist data to display!
                </div>

                <ul class="gap-6 lg:gap-12 grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4">
                    <li :for={artist <- @page.results}>
                    <.artist_card artist={artist} />
                    </li>
                </ul>

                # Now we only show 1 page of results and we will need a way to get to the next page of artists.
                <Layouts.app {assigns}>
                    # ...
                    <.pagination_links page={@page} query_text={@query_text}
                        sort_by={@sort_by} />
                </Layouts.app>

                # Now we need to make them work so lets use an other built-in functionality of ASH. AshPhoenix.LiveView, this will help us determine if or when we can get to an other page. We will do this in the pagination_links function.
                <div
                    :if={AshPhoenix.LiveView.prev_page?(@page) ||
                        AshPhoenix.LiveView.next_page?(@page)}
                    class="flex justify-center pt-8 space-x-4"
                    >
                    <.button_link data-role="previous-page" kind="primary" inverse
                        patch={~p"/?#{query_string(@page, @query_text, @sort_by, "prev")}"}
                        disabled={!AshPhoenix.LiveView.prev_page?(@page)}
                    >
                        « Previous
                    </.button_link>
                    <.button_link data-role="next-page" kind="primary" inverse
                        patch={~p"/?#{query_string(@page, @query_text, @sort_by, "next")}"}
                        disabled={!AshPhoenix.LiveView.next_page?(@page)}
                    >
                        Next »
                    </.button_link>
                </div>

                # Now we can set the query_string helper and we are more than on our way
                def query_string(page, query_text, sort_by, which) do
                    case AshPhoenix.LiveView.page_link_params(page, which) do
                    :invalid -> []
                    list -> list
                    end
                    |> Keyword.put(:q, query_text)
                    |> Keyword.put(:sort_by, sort_by)
                    |> remove_empty()
                end

                # You can now do some tests but we still need to make sure that we are only loading the right artists for each page, back to handle_params
                #... 
                page_params = AshPhoenix.LiveView.page_from_params(params, 12)
                page = Tunez.Music.search_artists!(query_text, query: [sort_input: sort_by], page: page_params)
    
            This utilized the right information and made sure that we are getting only the right artists for the right page.

    No DB field? No Problems, with Calculations
        Calculations are a great way to get information that is calculated on demand but they must be loaded with the data.

        Calculating Data with Style
            We can change the album resource to deal with Calculations, lib/tunez/music/album.ex. As you will see in this you are going to build the data for how long ago it was created.
                defmodule Tunez.Music.Album do
                    # ...
                
                    calculations do
                        calculate :years_ago, :integer, expr(2025 - year_released)
                    end

            If we wanted to use some more dynamic values we could define a separate calculate, we will use that later to define the seconds on a track. Here is a little test.
                iex(1) > Tunez.Music.get_artist_by_id(«uuid», load: [albums: [:years_ago]])
                {:ok, #Tunez.Music.Artist<
                    albums: [
                        #Tunez.Music.Album<year_released: 2022, years_ago: 3, ...>,
                        #Tunez.Music.Album<year_released: 2012, years_ago: 13, ...>
                    ],
                    ...
                >}

            Now lets add some or functionality
                calculations do
                    calculate :years_ago, :integer, expr(2025 - year_released)
                    calculate :string_years_ago,
                    :string,
                    expr("wow, this was released " <> years_ago <> " years ago!")
                end
        
        Calculations with Related Records
            Now we want to build some calculations for each artist that will contain: This will be done in the artists resource, lib/music/artist.ex
                The Number of albums
                The year of the latest album
                The most recent album cover

            "Counting Albums for an Artist"
                defmodule Tunez.Music.Artist do
                    # ...
                    calculations do
                        calculate :album_count, :integer, expr(count(albums))
                    end
                end

                Here is a test.
                iex(1)> Tunez.Music.search_artists("a", load: [:album_count])
                SELECT a0."id", a0."name", a0."biography", a0."previous_names",
                a0."inserted_at", a0."updated_at", coalesce(s1."aggregate_0", $1::bigint)
                ::bigint::bigint FROM "artists" AS a0 LEFT OUTER JOIN LATERAL (SELECT
                sa0."artist_id" AS "artist_id", coalesce(count(*), $2::bigint)::bigint AS
                "aggregate_0" FROM "public"."albums" AS sa0 WHERE (a0."id" = sa0."artist_id")
                GROUP BY sa0."artist_id") AS s1 ON TRUE WHERE (a0."name"::text ILIKE $3)
                ORDER BY a0."id" LIMIT $4 [0, 0, "%a%", 13]
                {:ok, %Ash.Page.Offset{...}}

            "Finding the Most Recent Album Release Year for an Artist"
                calculations do
                    calculate :album_count, :integer, expr(count(albums))
                    calculate :latest_album_year_released, :integer,
                        expr(first(albums, field: :year_released))
                end

            "Finding the Most Recent Album Cover for an Artist
                Okay so normally we would only want to return the covers for those artists that have an album cover to return but Ash will automatically only return non-nil values, although it can still return nil if needs be. So lets add in the album cover and go from there.
                calculate :cover_image_url, :string,
                    expr(first(albums, field: :cover_image_url))

            We have now set all those values that will be triggered with the data that we pull as long as we ask for them. Keep in mind that you will only get the data that you ask for even if you need to calculate an other calculation to get it.

    Relationship Calculations as Aggregates
        There are a bit more in-depth than a calculation but use a lot of the same ideas but have a more streamlined syntax we are staying in lib/tunez/music/artist.ex
            defmodule Tunez.Music.Artist do
                # ...

                aggregates do
                    # calculate :album_count, :integer, expr(count(albums))
                    count :album_count, :albums

                    # calculate :latest_album_year_released, :integer,
                    # expr(first(albums, field: :year_released))
                    first :latest_album_year_released, :albums, :year_released
                    
                    # calculate :cover_image_url, :string,
                    # expr(first(albums, field: :cover_image_url))
                    first :cover_image_url, :albums, :cover_image_url
                end

        See how much easier it is to utilize aggregates. Now lets implement them.

        Using Aggregates like any other Attribute
            As it sounds we simply need to add the attribute to to the resource and we are set to go. Head to lib/tunez_web/live/artists/index_live.ex and head to the artist_card function
                <div id={"artist-#{@artist.id}"} data-role="artist-card" class="relative mb-2">
                    <.link navigate={~p"/artists/#{@artist.id}"}>
                        <.cover_image image={@artist.cover_image_url} />
                    </.link>
                </div>

            We could add in the other calculations but in this case there is yet an other built-in ASH function to prepare the build which will automatically load those values. This would be the "normal" way to do it.
                page =
                Tunez.Music.search_artists!(query_text,
                    page: page_params,
                    query: [sort_input: sort_by],
                    load: [:album_count, :latest_album_year_released, :cover_image_url]
                )

            Here is an other way to do it by going into the read :search and setting a prepare build
                read :search do
                    # ...
                    prepare build(load: [:album_count, :latest_album_year_released,
                        :cover_image_url])
                end

            For our purposes we will go to lib/tunez/music.ex domain and add in the defaults to the search_artists.
                define(:search_artists,
                    action: :search,
                    args: [:query],
                    default_options: fn ->
                    [load: [:album_count, :latest_album_year_released, :cover_image_url]]
                    end
                )

            Now let's head back to lib/tunez_web/live/artists/index_live.ex and add in the information that we wanted to load.
                def artist_card(assigns) do
                    ~H"""
                    <% # ... %>
                    <.artist_card_album_info artist={@artist} />
                    """
                end

        Sorting Based on Aggregate Data
            Now we can even add in some sorting params based off those data options. Still in the index_live.ex add these to the sorting options.
                defp sort_options do
                    [
                    {"recently updated", "-updated_at"},
                    {"recently added", "-inserted_at"},
                    {"name", "name"},
                    {"number of albums", "-album_count"},
                    {"latest album release", "-latest_album_year_released"}
                    ]
                end

            Now we simply make them public and we are set head to lib/tunez/music/artist.ex
                aggregates do
                    count :album_count, :albums do
                        public? true
                    end
                    first :latest_album_year_released, :albums, :year_released do
                        public? true
                    end
                    # ...
                end

            We did it we are now all set to finish this part of the project!!!

Chapter 4: Generating APIs Without Writing Code (85)
    We now want to make an API so that other users can access our data in their own apps.
    
    Model Your Domain, Derive the Results
        In this chapter we will build a REST and GraphQL API for other users to access our data.

    Building A JSON REST interface
        We will use some built in ASH package to generate the API that will accept requests over HTTP and the send the data in a JSON format

        Setup
            Lets add some features to the app. This will be done with and igniter install, here is what it will do: 
                ash_json_api Hex package
                Code formatting and configuration to support a new application/vnd.api+json
                New TunezWeb.AshJsonApiRouter
                A new scope for the Phoenix router.

                mix igniter.install ash_json_api

        Adding Artists to the API
            We will try and implement the CRUD for the API and as such we will need to add each resource and then make them public. We will use the extend Mix task to do so. A couple of things that this will do:
                AshJsonApi.Resource will be added to make use of the new access point
                A default API type will be added to the resource.
            Since it is the first resource for Music it will connect the pieces of the domain
                AshJsonApi.Domain will be added as an extension of the Tunez.Music domain
                Tunez.Music will be added to the list of domains in the TunezWeb.AshJsonApiRouter module.
                mix ash.extend Tunez.Music.Artist json_api

            Now we need to set some of the routes to make the actions on the Artist resource available in the API. We could add the domain or the resource to the API but it makes more sense to add a layer of obfuscation so that a user can only interact with the top layer of the domain. Head to lib/tunez/music.ex
                defmodule Tunez.Music do
                    # ...
                    json_api do
                            routes do
                            base_route "/artists", Tunez.Music.Artist do
                                get :read
                                index :search
                                post :create
                                patch :update
                                delete :destroy
                            end
                        end
                    end
                end
            
            This will set some default actions for each user for each artist. GET and artist POST will create an artist, and so on. We can check the routes from a the WSL console
                mix phx.routes

            You can even use the GET route by accessing http://localhost:4000/api/json/artists/?query=and

            "What Data Gets Included in API Responses?
                So you might notice that some of the data is missing and that is because only the attributes that are made public are included. This is a security thing and can be changed. Lets add the biography and the previous_names to the public list, head to lib/tunez/music/artist.ex
                    attributes do
                        # ...

                        attribute :previous_names, {:array, :string} do
                            default []
                            public? true
                        end

                        attribute :biography, :string do
                            public? true
                        end
                        # ...
                    end
            
                Calculations and Aggregates are different as they can be calculation expensive so there are a few ways to make them visible to the API:
                    Set them as default fields at the resource level. This will be done EVERYTIME that the resource is pulled. 
                    Make it so that a user can request the specific calculation or aggregates that they require. They will need to add the field to the query string parameters. Something like http://localhost:4000/api/json/artists?fields=name,album_count . THis is a default response in the ASH framework.

            "Creating Artists Records"
                There is quite a few routes that were created and we will just go over the post but with the right body and route you can use the API to create an artist as well. 

                The PATCH can update and the DELETE can remove an artist.
        
        Adding Albums to the API
            We can use the same extension to add albums to the API as well. Afterwards we will need to add in the routes and default actions that we want the API route to be able to use.
                mix ash.extend Tunez.Music.Album json_api
            
            Now we need to head to lib/tunez/music.ex to add in the routes as we did before
                json_api do
                    routes do
                        # ...

                        base_route "/albums", Tunez.Music.Album do
                            post :create
                            patch :update
                            delete :destroy
                        end
                    end

            We now have the way to work with the albums but we don't have a nice way of dealing with the artist_id that is usually pre-hidden in the HTTP request. We will need to provide a valid ID for that and we will need to head into the album.ex to make those values public. Head to lib/tunez/music/album.ex to make those changes.
                attributes do
                    uuid_primary_key :id
                    attribute :name, :string do
                        allow_nil? false
                        public? true
                    end
                    attribute :year_released, :integer do
                        allow_nil? false
                        public? true
                    end
                    attribute :cover_image_url, :string do
                        public? true
                    end
                    # ...

            "Showing Albums for a Given Artist"
                There are to ways to include related resources for a given resource. Both will require that the relationship is public. Head to lib/tunez/music/artist.ex to set that now.
                    relationships do
                        has_many :albums, Tunez.Music.Album do
                            sort year_released: :desc
                            public? true
                        end
                    end

            "Including Related Records"
                The easiest way and it mirrors the way we have done things like this before and that is to include it in the json_api parent resource. Like this http://localhost:4000/api/json/artists?query=cove&amp;include=albums
                    json_api do
                        type "artist"
                        includes [:albums]
                    end
            
            "Linking to a List of Related Records"
                You can add a link the the records that the user might want wit the GET call to the API. This will require heading into lib/tunez/music.ex and adding in a related relationship to the API response.
                    base_route "/artists", Tunez.Music.Artist do
                        # ...
                        related(:albums, :read, primary?: true)
                    end
                    
        Generating API Documentation with OpenApiSpex
            The installation of AshJsonApi also included a way to build some Documentation with ease. We just need to add in the route. Head to lib/tunez_web/ash_json_api_router.ex to see what it already did. http://localhost:4000/api/json/open_api
                defmodule TunezWeb.AshJsonApiRouter do
                    use AshJsonApi.Router,
                        domains: [Tunez.Music],
                        open_api: "/open_api"
                end

            Now this is just a json result with all the information but not a clear way of using it you can use the built in functionality of swaggerui to format it much better. Head to lib/tunez_web/router.ex this will made the route api/json/swaggerui available
                scope "/api/json" do
                    pipe_through [:api]

                    forward "/swaggerui", OpenApiSpex.Plug.SwaggerUI,
                    path: "/api/json/open_api",
                    default_model_expand_depth: 4

                    forward "/", TunezWeb.AshJsonApiRouter
                end

        Customizing the Generated API
            Lets tackle some low hanging fruit and make it look better and work better.
            
            "Adding Informative Descriptions"
                Ash allows us to set some descriptors for all the resources that we have in order to make any Documentation or calls be better understood.
                    A description for a resource as a whole. or
                    A description for an action or an argument for an action

                Take some time and add in a few of those here are some to get you started
                    defmodule Tunez.Music.Artist do
                        use Ash.Resource, ...
                        resource do
                            description "A person or group of people that makes and releases music."
                        end

                        read :search do
                            description "List Artists, optionally filtering by name."
                            argument :query, :ci_string do
                                description "Return only artists with names including the given value."
                                # ...

            "Updating the API Title and Version"
                Head to lib/tunez_web/ash_json_api_router.ex and then add some lines so that when you are using the route there is a title and version in the heading.
                    defmodule TunezWeb.AshJsonApiRouter do
                        use AshJsonApi.Router,
                            domains: [Tunez.Music],
                            open_api: "/open_api",
                            open_api_title: "Tunez API Documentation",
                            open_api_version: to_string(Application.spec(:tunez, :vsn))
                    end

            "Removing Unwanted Extras"
                If you took some time to look through the API docs you see that there is some filtering that we are not using as we have our own setup. You can disable the built in versions if you want and it is with the derive_filter? boolean flag. Head to tunez/music/artist.ex and add this line.
                    json_api do
                        type("artist")
                        includes([:albums])
                        derive_filter?(false)
                    end

    Building a GraphQL interface
        This is an other way to do the same things but this will do a few different things. We will go over those in the next section.

        Setup
            Using a similar igniter install we will be doing some different things:
                Code formatting and configuration for AshGraphql and Absinthe
                New graphql pipeline and scope for your Phoenix router, taking /gql and /gqp/playground
                New TunezWeb.GraphqlSchema
                New TunezWe.GraphqlSocket
            You can head to http://localhost:4000/gql/playground after we get it all setup.
                mix igniter.install ash_graphql

            This next bit will go fast as there is a lot that we have done that will look very similar
        
        Adding Artists to the API
            mix ash.extend Tunez.Music.Artist graphql

            We will now need to add in the queries and actions for the new API route. Head to lib/tunez/music.ex and add this new block.
                graphql do
                    queries do
                        get Tunez.Music.Artist, :get_artist_by_id, :read
                        list Tunez.Music.Artist, :search_artists, :search
                    end
                end

            This will create queries named getArtistById and searchArtistById that connects to the read action. We can now now add some non read options that will all be mutations, same file
                graphql do
                    # ...

                    mutations do
                    create Tunez.Music.Artist, :create_artist, :create
                    update Tunez.Music.Artist, :update_artist, :update
                    delete Tunez.Music.Artist, :destroy_artist, :destroy
                    end
                end

            "What Data Gets Included in API Responses?"
                We already did this in the previous section so this will not change anything

            "Creating Artist Records"
                Same as before this will not change.
        
        Adding Albums to the API
            We will use the same ash.extend but for graphql and albums then we will need to set the mutations for the graphql
                mix ash.extend Tunez.Music.Album graphql

            Then head to lib/tunez/music.ex
                graphql do
                    mutations do
                        # ...    
                
                        create Tunez.Music.Album, :create_album, :create
                        update Tunez.Music.Album, :update_album, :update
                        destroy Tunez.Music.Album, :destroy_album, :destroy
                    end
                end

            "Showing Albums for a Given Artist"
                Same as we did for the RESTful

        Customizing the Generated API
            Same as we did before we want to remove the unwanted fields it will be very similar but I will go over the needs for the graphql part

            "Removing Unwanted Extras"
                Here is where we will set the fields that will allows us to filter results, head to lib/tunez/music/artist.ex make these changes.
                    graphql do
                        type :artist
                        filterable_fields [:album_count, :cover_image_url, :inserted_at, :latest_album_year_released, :updated_at]
                    end

    That is it for this section hope you learned something.

Chapter 5: Authentication: Who Are You? (107)
    Introducing AshAuthentication
        There is 2 part to Authentication for ASH, the core ash_authentication and then the ash_authentication_phoenix. For this chapter we will just be letting the ash installer do most of the work but will be going over each step as is needed. First lets get the right Igniter to install the ash_authentication
            mix igniter.install ash_authentication

        New Domain, Who's This?
            So as before we were working with domains and we had Tunez.Music, Authentication is an other type here that will be used to deal with the users. We just made Tunez.Accounts that will have 2 resources, Tunez.Accounts.User and Tunez.Accounts.Token

            Tunez.Accounts.User in lib/tunez/accounts/user.ex is for the Users that we will make and deal with. There is also a DB setup for users in the users database, it doesn't have much at the moment besides ID, and some boilerplate for the configuration

        Tokens and Secrets and Config, Oh My!
            Tokens, via Tunez.Accounts.Token resource are the secret sauce for AshAuthentication. This is how we will identify a user. They will be provided upon request for every session that a user will need. It should be good right out the box but there are ways to change settings, in the mean time the only thing we need to do now to make this all work is to set up a strategy for the Authentication.

    Setting Up Password Authentication
        The normal way that most people will use Authentication is to set up a password and user name and then enter those in-order to access the website. There are other ways of doing this like; OAuth and magic links but we will use the password strategy for this site. It is a simple command line to take care of this. This will add in these bits of code:
            2 new attributes for Tunez.Accounts.User email and hashed_password
            Strategies block added to Authentication config in Tunez.Accounts.User resource
            confirmation add-on added to the add_ons block as part of authentication config in Tunez.Accounts.User, this will require the user to authenticate their emails.
            A whole set of actions in Tunez.Accounts.Users for signing in. 
            2 modules to handle sending email confirmations, and password reset.

            mix ash_authentication.add_strategy password 
        
        With the mix done you will now need to mix ash.migrate to set up the new repo and db
            mix ash.migrate

        Testing Authentication Actions in iex
            One of the actions that we created with the generator is create:register_with_password action. This should take an: email, password, and password_confirmation and creates a user record. Lets test it out.
                iex -S mix
                iex(1)> Tunez.Accounts.User
                Tunez.Accounts.User                
                iex(2)> |> Ash.Changeset.for_create(:register_with_password, %{email: <<email>>, password: "supersecret", password_confirmation: "supersecret"})
                #Ash.Changeset<
                domain: Tunez.Accounts,
                action_type: :create,
                action: :register_with_password,
                attributes: %{email: #Ash.CiString<"***email***">},
                relationships: %{},
                arguments: %{
                    password: "**redacted**",
                    email: #Ash.CiString<"***email***">,
                    password_confirmation: "**redacted**"
                },
                errors: [],
                data: %Tunez.Accounts.User{
                    id: nil,
                    email: nil,
                    confirmed_at: nil,
                    __meta__: #Ecto.Schema.Metadata<:built, "users">
                },
                valid?: true
                >
                iex(3)> |> Ash.create!(authorize?: false)
                [debug] QUERY OK db=0.3ms idle=527.3ms
                begin []
            
            This did a few things added a new user into the db, created a token for the user to authenticate and confirm their email, generated an email that will be sent out (This wont be done in dev but all the pluming will be there for it.) Now what can we do with this?  Lets try to authenticate with a faux form to do so.
                iex(1)> Tunez.Accounts.User
                Tunez.Accounts.User
                iex(2)> |> Ash.Query.for_read(:sign_in_with_password, %{email: "***email***", password: "supersecret"})
                #Ash.Query<
                resource: Tunez.Accounts.User,
                action: :sign_in_with_password,
                arguments: %{
                    password: "**redacted**",
                    email: #Ash.CiString<"***email***">
                },
                filter: #Ash.Filter<email == #Ash.CiString<"***email***"> and not  is_nil(hashed_password) == "**redacted**">
                >
                iex(3)> |> Ash.read(authorize?: false)
                [debug] QUERY OK source="users" db=1.9ms decode=1.6ms queue=0.8ms idle=765.6ms
                SELECT u0."id", u0."email", u0."confirmed_at", u0."hashed_password" FROM "users" AS u0 WHERE (u0."email"::citext = ($1::citext)::citext) AND (NOT (u0."hashed_password"::text IS NULL)) ...
                ↳ AshPostgres.DataLayer.bulk_create/3, at: lib/data_layer.ex:2024
                {:ok,
                [
                %Tunez.Accounts.User{
                    id: "cd36f5a7-9f3e-460b-bd45-cdc92367dbfe",
                    email: #Ash.CiString<"***email***">,
                    confirmed_at: nil,
                    __meta__: #Ecto.Schema.Metadata<:loaded, "users">
                }
                ]}

            Don't forget each line but you should have the user in the db and then you should be able to find the user with these commands. You can even check the token for the user with the right permissions.
                iex(4)> {:ok, [user]} = v()
                {:ok,
                [
                %Tunez.Accounts.User{
                    id: "cd36f5a7-9f3e-460b-bd45-cdc92367dbfe",
                    email: #Ash.CiString<"***email***">,
                    confirmed_at: nil,
                    __meta__: #Ecto.Schema.Metadata<:loaded, "users">
                }
                ]}
                iex(5)> user.__metadata__.token
                "eyJhbGciOiJIUzI1NiIsInR5cCI6Ik..."

            Now lets test out the verification by use the JSON Wet Token (JWT)
                iex(6)> AshAuthentication.Jwt.verify(user.__metadata__.token, :tunez)
                [debug] QUERY OK source="tokens" db=0.5ms queue=0.6ms idle=1175.7ms
                SELECT TRUE FROM "tokens" AS t0 WHERE (t0."purpose"::text = $1::text) AND (t0."jti"::text = $2::text) LIMIT 1 ...
                "purpose" => "user",
                "sub" => "user?id=cd36f5a7-9f3e-460b-bd45-cdc92367dbfe"
                }, Tunez.Accounts.User}

            The interesting part is the purpose and the sub, you can use a JWY's for a variety of reasons for this case we are verifying a user. Now that we have the JWT we can see if a user is using the right JWT and their token.
                iex(15)> {:ok, claims, resource} = v()
                {:ok, %{...}, Tunez.Accounts.User}
                iex(16)> AshAuthentication.subject_to_user(claims["sub"], resource)
                SELECT u0."id", u0."confirmed_at", u0."hashed_password", u0."email" FROM
                "users" AS u0 WHERE (u0."id"::uuid::uuid = $1::uuid::uuid) [«uuid»]
                {:ok, %Tunez.Accounts.User{email: #Ash.CiString<«your email»>, ...}}

            You don't need to worry about all of this but again a user will log in and then receive a token that will work for only them.

    Automatic UIs with AshAuthenticationPhoenix
        Now that we have a way to create a user and then get their token we need a UI for that. We will not use an other igniter to get this done, the command is below and it will:
            Set the config file in .igniter.exs this is the first generator that needs a specific configuration
            TunezWeb.AuthOverrides module that will customize the look, see (lib/tunez_web/auth_overrides.ex)
            TunezWeb.AuthController module to securely process sign-in requests. (in lib/tunez_web/controller)
            TunezWeb.LiveUserAuth module providing a set of hooks we can use in live-views (lib/tunez_web/live_user_auth.ex)
            updates our router to handle the new plugs and routes (lib/tunez_web/router.ex)
            mix igniter.install ash_authentication_phoenix

        Okay that is all taken care of but as of right now Igniter doesn't know how to patch JavaScript or CSS files. We need to add Tailwinds live-view paths to the assets. Head to /assets/css/app.css and add in this line
            /* ... */
            @source "../../lib/tunez_web";
            @source "../../deps/ash_authentication_phoenix";
            
            @plugin "@tailwindcss/forms";
            /* ... */

        Now you can head to /sign-in to see the login page. You can create a user (try the one you already made) you will then be redirected to the home page, we will not work on making it look like you are logged in.

        Showing the Currently Authenticated User
            It is normal for it to show the current user in the top right so let's do that now. Head to lib/tunez_web/components/layouts.ex and lets add in a line to show the current user.
                <div class="flex items-center w-full p-4 pb-2 border-b-2 border-primary-600">
                    <div class="flex-1 mr-4">
                        <% # ... %>
                    </div>
                    <.user_info current_user={@current_user} socket={@socket} />
                </div>
            
            Now we have the line that will show the current user but its not public and we now need to dig into why its not showing the current user.

            "Digging into AshAuthenticationPhoenix's Generated Router Code"
                Most everything the generator did is perfect but there are a few things that it didn't do for us. It set up some pipelines for load_from_bearer, and load_from_session, these are for the JWT and are able to load the record for the user. But live-view works differently we need to find a way to get the session info into the current session as live-view knows that they are authenticated but not the session that was created for the user. 

                This is where live_session comes in. It's wrapped in ash with AshAuthentication, ash_authentication_live_session, this will make sure that when new sessions are spawned they will have the correct data and will still be secure. So for Tunez we need to make sure that the routes that need to be logged in will be in the ash_authentication_live_session block. so these first routes need to be moved into the correct block. lib/tunez_web/router.ex
                    scope "/", TunezWeb do
                        pipe_through :browser
                        # This is the block of routes to move
                        live "/", Artists.IndexLive
                        # ...
                        live "/albums/:id/edit", Albums.FormLive, :edit
                        auth_routes AuthController, Tunez.Accounts.User, path: "/auth"
                        # ...
                        # will be moved to this should be higher up in the block of code.

                    scope "/", TunezWeb do
                        pipe_through :browser
                        ash_authentication_live_session :authenticated_routes do
                        # This is the location that the block of routes should be moved to
                        live "/", Artists.IndexLive
                        # ...
                        live "/albums/:id/edit", Albums.FormLive, :edit
                        end
                    end

        Stylin' and Profilin' with AuthOverrides
            There is a file that was created to change some of the standard components class names and url images etc. Let's head to lib/tunez_web/auth_overrides.ex. It can be hard to figure out exactly what we want to override here. To maybe help the submit button is an input. Let's override the input component. Within the file you will see some syntax for doing some of the overrides. 
                # add this into the file
                override AshAuthentication.Phoenix.Components.Password.Input do
                    set :submit_class, "bg-primary-600 text-white my-4 py-3 px-5 text-sm"
                end

            There it is the button is now purple, keep in mind that anything you do here you will change for every instance of the component. They provided a set of overrides in lib/tunez_web/auth_overrides_sample.txt but if don't see it here it is for you.
                alias AshAuthentication.Phoenix.Components

                override Components.Banner do
                    set :image_url, nil
                    set :dark_image_url, nil
                    set :text_class, "text-8xl text-accent-400"
                    set :text, "♫"
                end

                override Components.Password do
                    set :toggler_class, "flex-none text-primary-600 px-2 first:pl-0 last:pr-0"
                end

                override Components.Password.Input do
                    set :field_class, "mt-4"
                    set :label_class, "block text-sm font-medium leading-6 text-zinc-800"
                    set :input_class, TunezWeb.CoreComponents.form_input_styles()

                    set :input_class_with_error, [
                        TunezWeb.CoreComponents.form_input_styles(),
                        "!border-error-400 focus:!border-error-600 focus:!ring-error-100"
                    ]

                    set :submit_class, [
                        "phx-submit-loading:opacity-75 my-4 py-3 px-5 text-sm",
                        "bg-primary-600 hover:bg-primary-700 text-white",
                        "rounded-lg font-medium leading-none cursor-pointer"
                    ]

                    set :error_ul, "mt-2 flex gap-2 text-sm leading-6 text-error-600"
                end

                override Components.MagicLink do
                    set :request_flash_text, "Check your email for a sign-in link!"
                end

                override Components.MagicLink.Input do
                    set :submit_class, [
                        "phx-submit-loading:opacity-75 my-8 mx-auto py-3 px-5 text-sm",
                        "bg-primary-600 hover:bg-primary-700 text-white",
                        "rounded-lg font-medium leading-none block cursor-pointer"
                    ]
                end

                override Components.Confirm.Input do
                    set :submit_class, [
                        "phx-submit-loading:opacity-75 my-8 mx-auto py-3 px-5 text-sm",
                        "bg-primary-600 hover:bg-primary-700 text-white",
                        "rounded-lg font-medium leading-none block cursor-pointer"
                    ]
                end

        Why Do Users Always Forget Their Passwords!?
            When we did the initial setup for AshAuthentication we did 2 things (senders) that will send emails for confirmation and password reset. SendNewUser ConfirmationEmail SendPasswordResetEmail.

            Phoenix apps come with Swoosh that is designed for sending emails. Each sender function does two things: body/1 (generates content) and send/3 that is for constructing and sending the email. There is going to need a email provider to send the emails. However during production you will need to have a place to hold those emails, it will be at http://localhost:4000/dev/mailbox. 

    Setting Up Magic Link Authentication
        Nowadays there is ways to setup some magic links that will just be sent to a user in order to just use the link to log-in. Ash has this in the box. Lets try the magic link method. With the command below it will do the following:
            Add a new magic_link authentication strategy to the Tunez.Accounts.User resource, lib/tunez/accounts/user.ex
            Add to new actions sign_in_with_magic_link and request_magic_link in Tunez.Accounts.User resource.
            Remove allow_nil? false, on the hashed_password in Tunez.Accounts.User resource.
            Add a new sender module responsible for generating the magic link email, in lib/tunez/accounts/user/senders/send_magic_link_email.ex
            mix ash_authentication.add_strategy magic_link

            Then as always migrate
            mix ash.migrate

        Boom We now have the 2 options.

        Debugging When Authentication Goes Wrong
            We might need to debug, with more robust error messages during dev. In order to do that we can head to /config/dev.exs and add this to the bottom.
                config :ash_authentication, debug_authentication_failures?: true

            Restart the server and head to the same magic link and you should see more within the error log, what is it telling you is that the link has already been used. Without the robust logging you might never be able to understand what is happening. 

        Can We Allow Authentication over Our API?
            We can even do all of this over API, First let's set up the command then we can start to lock down the paths over api.
                mix ash.extend Tunez.Accounts.User json_api

            This made is sure that we have some new actions and then we need to add in a new route with the action register_with_password action. Head to lib/tunez/accounts.ex
                defmodule Tunez.Accounts do
                    use Ash.Domain, otp_app: :tunez, extensions: [AshJsonApi.Domain]

                    json_api do
                        routes do
                        base_route "/users", Tunez.Accounts.User do
                            post(:register_with_password, route: "/register")
                        end
                        end
                    end

                    # ...
                end

            Okay so we have the new route and much more but at the time we can't use the API as there is too much locked down and we don't want people to change peoples password as the API could allow people to do that. 

Chapter 6: Authorization: What Can You Do? (123)
    We have the app in a good place so that we can do everything we want but the permissions aren't all set up and the API doesn't have any Authorization. We want to also make act different when you are logged in and when you are not logged in. 
    
    Introducing Policies
        This is where we set the policies. Ash will check internally for all the policies before any action takes place if one fails then it will not happen.

        We write them once and then they will be done everywhere. At it's core we need to understand who is running the actions so we need to define the actors well. The policy is made up of 2 things:
            One or more policy conditions, helps to determine whether or not the policy applies to a situation.
            A set of policy checks, that will pass or fail. There is a check condition and then an action if it passes. 

        Lets say we were building a blog site a check might look like. 
            defmodule Blog.Post do
                use Ash.Resource, authorizers: [Ash.Policy.Authorizer]
                    policies do
                        policy action(:publish) do
                            forbid_if expr(published == true)
                            authorize_if actor_attribute_equals(:role, :admin)
                        end
                    end
                end
            # This will check during an publish action and not do it is already published or if they are not an admin.

        Decisions, Decisions
            For a policy we need to think of it as a cond statement. The check will be evaluated in order and if one succeeds then it will run, order matters here. If nothing makes a decision then it will fail and nothing will happen. 
        
    Authorizing API Access for Authentication
        Let's start to use this in our app. There are some basic setting that are set already head to lib/tunez/accounts/user.ex
            policies do
                bypass AshAuthentication.Checks.AshAuthenticationInteraction do
                    authorize_if(always())
                end

                policy always() do
                    forbid_if(always())
                end

        Looking at this we see that bypass that we will get into later but the AshAuthentication.Checks.AshAuthenticationInteraction is any action from the liveview. The second policy always applies and will fail if... always. This is any other action that is not through liveview again going back to the order of operations. We need to update that so that we can use the API

        Writing Our First User Policy
            Let's first look at what happens without the authorization to get a better look at what is happening under the hood.
                iex -S mix
                iex(1)> Tunez.Accounts.User
                Tunez.Accounts.User
                |> Ash.Changeset.for_create(:register_with_password, %{email: "Test@test.com", password: "password", password_confirmation: "password"})
                #Ash.Changeset<
                domain: Tunez.Accounts,
                ...>
                iex(3)> |> Ash.create()
                {:error,
                %Ash.Error.Forbidden{
                bread_crumbs: ["Error returned from: Tunez.Accounts.User.register_with_password"], 
                changeset: "#Changeset<>", 
                errors: [
                    %Ash.Error.Forbidden.Policy{...}
                ]}}

            Let's set some changes to make it so we have some functionality without liveview. Same file but now we change this.
                policies do
                    bypass AshAuthentication.Checks.AshAuthenticationInteraction do
                        authorize_if(always())
                    end

                    policy action([:register_with_password, :sign_in_with_password]) do
                        authorize_if(always())
                    end
                end
                # You will not be able to do those action without it failing. Check for yourself. Just make sure to recompile.

        Authentication via JSON
            Just a quick bit of information I was able to download and install the Postman app [https://www.postman.com/downloads/] in order to send and receive data through the api. I used a general body to send the info but I needed a proper header which was just what it will send and accept ad a return.
                Content-Type: application/vnd.api+json
                Accept: application/vnd.api+json

            We tested out a token for sign-in last time and for registration it should be very similar, we need to also be sure the send the token to the user so they can store it and use it later. This is handled for us by AshAuthenticationPhoenix, we can then attach the metadata to the API response, head to lib/tunez/accounts.ex and add these lines.
                json_api do
                    routes do
                        post :register_with_password do
                            route("/register")

                            metadata(fn _subject, user, _request ->
                            %{token: user.__metadata__.token}
                            end)
                        end
                    end
                end

            We can then do the same for sign_in_with_password
                post :sign_in_with_password do
                    route("/sign_in")
                    metadata(fn _subject, user, _request -> %{token: user.__metadata__.token} end)
                end

        Authenticating via GraphQL
            This should be easier now that we have added in the policies for the access points. Start off the a linux command line, this will configure the GraphQL schema, domain module, and resource.
                mix ash.extend Tunez.Accounts.User graphql

            AshGraphql is strict in regards to which type of actions can do which. Mutations and queries are the 2 forms that we will work with Reads will be queries and updates, creates, etc will be mutations. Lets create the mutation for register_with_password, lib/tunez/accounts.ex
                graphql do
                    mutations do
                     create(Tunez.Accounts.User, :register_user, :register_with_password)
                    end
                end

            Now just do similar for the sign_in_with_password but use the queries using the get macro
                queries do
                    get(Tunez.Accounts.User, :sign_in_user, :sign_in_with_password)
                end

            We will get an error as they way that GraphQL works is that it has more fields for the return data and as such it doesn't know what to do with the token we can now add in a line to describe what to do with the Token
                get(Tunez.Accounts.User, :sign_in_user, :sign_in_with_password) do
                    type_name :user_with_token
                end

    Assigning Roles to Users
        For this app we don't need super robust roles just we need roles that will take care of the following:
            Basic no modification
            Editors create/update a limited set
            Admins any action across the app

        This role will be stored in the Tunez.Accounts.User and will be named role. So lets head to lib/tunez/accounts/user.ex
            attributes do
                # ...
                
                attribute :role, :atom do
                    allow_nil? false
                    default :user
                    constraints [one_of: [:user, :editor, :admin]]
                end
            end

        But there is a better way and we can just make a role.ex module and then reference that in the user.ex module.
            lib/tunez/account/role.ex
            defmodule Tunez.Accounts.Role do
                use Ash.Type.Enum, values: [:admin, :editor, :user]
            end
        
            lib/tunez/account/user.ex
                attribute :role, Tunez.Accounts.Role do
                    allow_nil? false
                    default :user
                end

        Now we just need to codegen and then migrate
            mix ash.codegen add_role_to_user
            mix ash.migrate

        Okay so now that we have the new migration and db we need a way to set and update the role for a user as everyone will be a user to start and no one will ever be an admin or editor. We can simply set a new action update :set_role that will accept role. lib/tunez/accounts/user.ex
            actions do
                defaults [:read]

                update :set_role do
                    accept [:role]
                end

                # ...
            end

        Now that we have that set we need to update the domain to be able to use the new action for the resource. lib/tunez/accounts.ex
            resources do
                # ...
                resource(Tunez.Accounts.User) do
                    define :set_user_role, action: :set_role, args: [:role]
                    define :get_user_by_email, action: :get_by_email, args: [:email]
                end
            end

        As we should only be running these from the console we don't need the authorize? false, once this is set and you have an account make it an admin like so
            iex -S mix
            iex(12)> user = Tunez.Accounts.get_user_by_email!(<email>, authorize?: false)
            %Tunez.Accounts.User{
            id: "9cb1d8b7-9231-4d16-930e-8e87a6db97ce",
            email: #Ash.CiString<<email>>,
            confirmed_at: ~U[2025-10-07 22:06:04.300165Z],
            role: :user,
            __meta__: #Ecto.Schema.Metadata<:loaded, "users">
            }
            iex(13)> Tunez.Accounts.set_user_role(user, :admin, authorize?: false)
            {:ok,
            %Tunez.Accounts.User{
            id: "9cb1d8b7-9231-4d16-930e-8e87a6db97ce",
            email: #Ash.CiString<<email>>,
            confirmed_at: ~U[2025-10-07 22:06:04.300165Z],
            role: :admin,
            __meta__: #Ecto.Schema.Metadata<:loaded, "users">
            }}
            
    Writing Policies for Artists
        Now we need to be sure that we are able to use these roles in an Ash Web app, there is 2 things that need to be done:
            Creating policies for our Resource
            Updating the interface to specify the actor, as well as hiding some UI for the right actors.

        Creating Our First Artist Policy
            Okay so let's head to lib/tunez/music/artist.ex and set up the authorizer for the module. 
                defmodule Tunez.Music.Artist do
                    use Ash.Resource,
                        otp_app: :tunez,
                        domain: Tunez.Music,
                        data_layer: AshPostgres.DataLayer,
                        extensions: [AshGraphql.Resource, AshJsonApi.Resource],
                        authorizers: [Ash.Policy.Authorizer]

            "Testing a create Action"
                We will get an error because we have nothing for that action (policy) and if there is no policy it will fail
                    iex -S mix
                    iex(15)> Tunez.Music.create_artist(%{name: "New Artist"})
                    {:error,
                    %Ash.Error.Forbidden{...}}

                We need to head to the artist resource and add in the policy lib/tunez/music/artist.ex, this is again a policy that will always work but we will change that later.
                    policies do
                        policy action(:create) do
                            authorize_if always()
                        end
                    end

                Lets add in the policy to make it only work for an admin.
                    policies do
                        policy action(:create) do
                         authorize_if actor_attribute_equals(:role, :admin)
                        end
                    end

                Now we can check to see how the iex  session works.
                    iex(2)> Tunez.Music.create_artist(%{name: "New Artist"})
                    {:error, %Ash.Error.Forbidden{...}}
                    iex(3)> Tunez.Music.create_artist(%{name: "New Artist"}, actor: nil)
                    {:error, %Ash.Error.Forbidden{...}}
                    iex(4)> editor = %Tunez.Accounts.User{role: :editor}
                    #Tunez.Accounts.User<role: :editor, ...>
                    iex(5)> Tunez.Music.create_artist(%{name: "New Artist"}, actor: editor)
                    {:error, %Ash.Error.Forbidden{...}}
                    iex(6)> admin = %Tunez.Accounts.User{role: :admin}
                    #Tunez.Accounts.User<role: :admin, ...>
                    iex(7)> Tunez.Music.create_artist(%{name: "New Artist"}, actor: admin)
                    {:ok, #Tunez.Music.Artist<...>}
            
        Filling Out Update and Destroy Policies
            Now let's figure out who can update and destroy anything. lib/tunez/music/artist.ex
                policies
                    policy action(:update) do
                        authorize_if actor_attribute_equals(:role, :admin)
                        authorize_if actor_attribute_equals(:role, :editor)
                    end
                        policy action(:destroy) do
                        authorize_if actor_attribute_equals(:role, :admin)
                    end
                
            "Cutting Out Repetitiveness with Bypasses"
                There is a way to avoid having to make a policy for every admin as we can set a bypass to make all actions work for that role. 
                    bypass actor_attribute_equals(:role, :admin) do
                        authorize_if always()
                    end
                
                With this set we can get rid of any polices that calls admin, and remember that if you don't have a policy for a role it will not work!!! Here are 2 things to keep in mind:
                    Keep all bypass policies together at the start of the policies block, and don’t intermingle them with standard policies.
                    • Write naive tests for your policies that test as many combinations of permissions as possible to verify that the behavior is what you expect. 
            
            "Debugging when Policies Fail"
                There is yet and other more robust debug that you can set to true in order to see more information about any failures. In config/deb.exs there is this line.
                    config :ash, policies: [show_policy_breakdowns?: true]

                Trying to do the same thing as create without the right permissions will result in an error
                    iex(1)> editor = %Tunez.Accounts.User{role: :editor}
                    #Tunez.Accounts.User<...>
                    iex(2)> Tunez.Music.create_artist!(%{name: "Oh no!"}, actor: editor)
                    ** (Ash.Error.Forbidden)
                    Bread Crumbs:
                    > Error returned from: Tunez.Music.Artist.create
                    Forbidden Error
                    * forbidden:
                    Tunez.Music.Artist.create
                    Policy Breakdown
                    user: %{id: nil}
                    Policy | [M]:
                    condition: action == :create
                    authorize if: actor.role == :admin | ✘ | [M]
                    SAT Solver statement:
                    "action == :create" and
                    (("action == :create" and "actor.role == :admin")
                    or not "action == :create")
                    Removing Forbidden Actions from the UI

        Filtering Results in read Action Policies
            Reads are a bit different as they are about filtering and giver entries that can satisfy a yes/no about a column. We won't modify too much here but the issues is that we might want to make it so an admin will see all records and a a normal user might not be able to see those. Either way we need to have a blanket policy for reads as again not policy no go. lib/tunez/music/artist.ex
                policies do
                    # ...
                    policy action_type(:read) do
                        authorize_if(always())
                    end
                end

    Removing Forbidden Actions from the UI
        Right now it will show all buttons no matter what the user role is there is a few things that we need to do in order to make sure that we only show the right information for each user:
            Update the actions to pass the current user
            Update forms to ensure that we only let the actor see the forms if they can submit them
            Update our templates to show show buttons if they have the right perms.

        Identifying the Actor When Calling Actions
            This could be the hardest part of the app in a larger scale version in our case the only action that are called directly are read and destroy. Tunez.Music.search_artists/2 in Tunez.Artists.IndexLive. We don't need to pass the actor as for NOW we allow all roles to search but that might change in the future. So let's get the information. lib/tunez_web/live/artists/index_live.ex
                 def handle_params(params, _url, socket) do
                    sort_by = Map.get(params, "sort_by") |> validate_sort_by()
                    query_text = Map.get(params, "q", "")
                    page_params = AshPhoenix.LiveView.page_from_params(params, 12)

                    page =
                        Tunez.Music.search_artists!(query_text,
                            query: [sort_input: sort_by],
                            page: page_params,
                            actor: socket.assigns.current_user
                        )
                
            Tunez.Music.get_artist_by_id/2 in Tunez.Artist.ShowLive, same as above let's add in the actor so we can use it later. lib/tunez_web/live/artists/show_live.ex
                artist =
                    Tunez.Music.get_artist_by_id!(artist_id,
                        load: [:albums],
                        actor: socket.assigns.current_user
                    )

            Tunez.Music.get_artist_by_id/2, in Tunez.Artists.FormLive. Same as before! lib/tunez_web/live/artists/form_live.ex
                artist =
                    Tunez.Music.get_artist_by_id!(artist_id,
                        load: [:albums],
                        actor: socket.assigns.current_user
                    )

            Tunez.Music.destroy_artist/2, in Tunez.Artists.ShowLive. We need to pass the actor in here to make it work, as only specific types of users can delete artists. lib/tunez_web/live/artists/show_live.ex
                def handle_event("destroy-artist", _params, socket) do
                    case Tunez.Music.destroy_artist(
                        socket.assigns.artist,
                        actor: socket.assigns.current_user
                    ) do

            Tunez.Music.destroy_album/2, in Tunez.Artists.ShowLive. We haven’t added policies for albums yet, but it doesn’t hurt to start updating our templates to support them.
                def handle_event("destroy-album", %{"id" => album_id}, socket) do
                    case Tunez.Music.destroy_album(
                        album_id,
                        actor: socket.assigns.current_user
                    ) do

            Tunez.Music.get_album_by_id/2, in Tunez.Albums.FormLive. Same as before. lib/tunez_web/live/albums/form_live.ex
                def mount(%{"id" => album_id}, _session, socket) do
                    album = Tunez.Music.get_album_by_id!(album_id,
                        load: [:artist],
                        actor: socket.assigns.current_user
                    )

            Tunez.Music.get_artist_by_id/2, in Tunez.Albums.FormLive. Same as before! Same file.
                def mount(%{"artist_id" => artist_id}, _session, socket) do
                artist = Tunez.Music.get_artist_by_id!(artist_id,
                    actor: socket.assigns.current_user
                )

        Updating Form to identify Actor
            This is where we utilize more Ash in order to only display the right things if we have the right roles. There is the AshPhoenix.Form.ensure_can_submit!(). lib/tunez_web/live/artists/form_live.ex
                def mount(%{"id" => artist_id}, _session, socket) do
                    # ...

                    form =
                    Tunez.Music.form_to_update_artist(
                        artist,
                        actor: socket.assigns.current_user
                    )
                    |> AshPhoenix.Form.ensure_can_submit!()

                def mount(_params, _session, socket) do
                    form = Tunez.Music.form_to_create_artist(
                        actor: socket.assigns.current_user
                    )
                    |> AshPhoenix.Form.ensure_can_submit!()

                Now we can make the same changes to the album as well. lib/tunez_web/live/albums/form_live.ex
                    def mount(%{"id" => album_id}, _session, socket) do
                        # ...
                        form =
                        Tunez.Music.form_to_update_album(
                            album,
                            actor: socket.assigns.current_user
                        )
                        |> AshPhoenix.Form.ensure_can_submit!()

                    def mount(%{"artist_id" => artist_id}, _session, socket) do
                        # ...
                        form = Tunez.Music.form_to_create_album(
                            artist_id,
                            actor: socket.assigns.current_user
                        )
                        |> AshPhoenix.Form.ensure_can_submit!()

        Blocking Pages from Unauthorized Access
            When we installed AshAuthenticationPhoenix there was some built-in features that we can use to be sure that we have a logged in user, during the on mount function. The live_user_optional function head will will not care if there is a user or not, live_no_user will redirect away if there is a user logged in, lastly live_user_required will require a user logged in. This below is a general syntax to use it.
                defmodule Tunez.Accounts.ForAuthenticatedUsersOnly do
                    use TunezWeb, :live_view
                        # or :live_user_optional, or :live_no_user
                        on_mount {TunezWeb.LiveUserAuth, :live_user_required}
                        # ...

            Let's use it in our app. lib/tunez_web/live_user_auth.ex this is where we can set some functionality to what happens on mount, lib/tunez_web/live_user_auth.ex
                def on_mount([role_required: role_required], _, _, socket) do
                    current_user = socket.assigns[:current_user]

                    if current_user && current_user.role == role_required do
                    {:cont, socket}
                    else
                    socket =
                        socket
                        |> Phoenix.LiveView.put_flash(:error, "Unauthorized!")
                        |> Phoenix.LiveView.redirect(to: ~p"/")

                    {:halt, socket}
                    end
                end

            This will allow us to leverage on on_mount for a given page. Like so...
                defmodule Tunez.Accounts.ForAdminsOnly do
                    use TunezWeb, :live_view
                    on_mount {TunezWeb.LiveUserAuth, role_required: :admin}
                    # ...

            Hiding Calls to Action That the Actor Can't Perform
                There are many different buttons all throughout the app that a user can and can't use depending on the role the user has. There must be a way to check to see if a user can do an action, that is where Ash.can? comes in.

                "Ash.can?"
                    Ash.can?16 is a pretty low-level function. It takes a tuple representing the action to call and an actor, runs the authorization checks for the action, and returns a boolean representing whether or not the action is authorized:
                        iex(1)> Ash.can?({Tunez.Music.Artist, :create}, nil)
                        false
                        iex(2)> Ash.can?({Tunez.Music.Artist, :create}, %{role: :admin})
                        true
                        iex(3) artist = Tunez.Music.get_artist_by_id!(«uuid»)
                        #Tunez.Music.Artist<id: «uuid», ...>
                        iex(4)> Ash.can?({artist, :update}, %{role: :user})
                        false
                        iex(5)> Ash.can?({artist, :update}, %{role: :editor})
                        true

                can_*? Code Interface Functions
                    We call these can_*? functions because the names are dynamically generated based on the name of the code interface. For our Tunez.Music domain, for example, iex shows a whole set of functions with the can_ prefix:
                        iex(1)> Tunez.Music.can_
                        can_create_album/1 can_create_album/2 can_create_album/3
                        can_create_album?/1 can_create_album?/2 can_create_album?/3
                        can_create_artist/1 can_create_artist/2 can_create_artist/3
                        ...

                    Now that we have these tools we can add checks for all the buttons on the app. There will be a few that need to be done so let's get started.

                    lib/tunez_web/live/artists/index_live.ex
                        <:action :if={Tunez.Music.can_create_artist?(@current_user)}>
                            <.button_link navigate={~p"/artists/new"} kind="primary">
                                New Artist
                            </.button_link>
                        </:action>

                    lib/tunez_web/live/artists/show_live.ex
                        <:action :if={Tunez.Music.can_destroy_artist?(@current_user, @artist)}>
                            <.button_link
                                kind="error"
                                inverse
                                data-confirm={"Are you sure you want to delete #{@artist.name}?"}
                                phx-click="destroy-artist"
                            >
                                Delete Artist
                            </.button_link>
                        </:action>
                        <:action :if={Tunez.Music.can_update_artist?(@current_user, @artist)}>
                            <.button_link navigate={~p"/artists/#{@artist.id}/edit"} kind="primary" inverse>
                                Edit Artist
                            </.button_link>
                        </:action>

                    lib/tunez_web/live/artists/show_live.ex
                        # This is in render 
                        <.button_link navigate={~p"/artists/#{@artist.id}/albums/new"} kind="primary"
                            :if={Tunez.Music.can_create_album?(@current_user, @artist)}>
                            New Album
                        </.button_link>

                        # This is in the album details section.
                        <:action :if={Tunez.Music.can_destroy_album?(@current_user, @album)}>
                            <.button_link
                            size="sm"
                            inverse
                            kind="error"
                            data-confirm={"Are you sure you want to delete #{@album.name}?"}
                            phx-click="destroy-album"
                            phx-value-id={@album.id}
                            >
                            Delete
                            </.button_link>
                        </:action>
                        <:action :if={Tunez.Music.can_update_album?(@current_user, @album)}>
                            <.button_link size="sm" kind="primary" inverse navigate={~p"/albums/#{@album.id}/edit"}>
                            Edit
                            </.button_link>
                        </:action>

                        # This is in render
                        <ul class="mt-10 space-y-6 md:space-y-10">
                            <li :for={album <- @artist.albums}>
                                <.album_details album={album} current_user={@current_user} />
                            </li>
                        </ul>

    Writing Policies for Albums
        Now we just want to be able to change some policies for the artists is as such:
            Everyone can read all artist data
            Editors can update (but not delete) artists.
            Admins can perform all actions

        Now we want to deal with albums we need to worry about editors being able to create albums and then edit/delete only those that they created.

        Recording Who Created and Last Modified a Resource
            We now need to create a relationship for the User in the album.ex so that we can keep track of who created and who last updated a record. lib/tunez/music/album.ex then do the same thing to Tunez.Music.Artists
                relationships do
                    # ...
                    belongs_to :created_by, Tunez.Accounts.User
                    belongs_to :updated_by, Tunez.Accounts.User
                end

            As always after a change to the DB we need to codegen and then migrate
                mix ash.codegen add_user_links_to_artists_and_albums
                mix ash.migrate

            Okay we have our new relationships now we can set some changes so that you can only do some actions if you are the created or and have the right perms. lib/tunez/music/album.ex
                defmodule Tunez.Music.Album
                    # ...
                    
                    changes do
                        change relate_actor(:created_by, allow_nil?: true), on: [:create]
                        change relate_actor(:updated_by, allow_nil?: true)
                    end
                end
                # Quick note about allow nil here there will be times like scripts that we want to have the created by etc not set as they will not have an owner.

            Lastly we need to unlock the actor in order to created the album etc as right not we don't have access to the actor. We need to head to lib/tunez/accounts/user.ex. This will allow a user to read their own record. 
                policies do
                    # ...
                    
                    policy action(:read) do
                        authorize_if expr(id == ^actor(:id))
                    end
                end

            Here is some testing results
                iex(1)> user = Tunez.Accounts.get_user_by_email!(«email», authorize?: false)
                #Tunez.Accounts.User<id: «uuid», email: «email», role: :admin, ...>
                iex(2)> Tunez.Music.create_artist(%{name: "Who Made Me?"}, actor: user)
                {:ok,
                #Tunez.Music.Artist<
                name: "Who Made Me?",
                updated_by_id: «uuid»,
                created_by_id: «uuid»,
                updated_by: #Tunez.Accounts.User<id: «uuid», ...>,
                created_by: #Tunez.Accounts.User<id: «uuid», ...>,
                ...
                >}

        Filling Out Policies
            Now that we have all that done we need to make the policies for the albums. 

Chapter 7: Testing Your Application (157)
    What Should We Test?

    Setting Up Data

    Consolidating Test Setup Logic

    Testing Resources

    Testing Interfaces

Chapter 8: Having Fun With Nested Forms (179)
    Setting Up a Track Resource
    
    Managing Relationships for Related Resources

    Reorder All of the Tracks!!!

    Automatic Conversions Between Seconds and Minutes

    Adding Track Data to API Responses

Chapter 9: Following Your Favorite Artists (207)
    Modelling with a Many-to-Many Relationship

    Who Do You Follow?

    Spicing Up the Artist Catalog

Chapter 10: Delivering Real-Time Updates with PubSub (225O)
    Notifying Users About New Albums

    Running Actions in Bulk

    Showing Notifications to Users

    Updating Notifications in Real Time
    
    We Need to Talk About Atomics

    Wrapping Everything Up